<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Cliff Shaffer" />
  <meta name="author" content="Peter Ljunglöf" />
  <meta name="author" content="Nick Smallbone" />
  <title>DSABook – The AVL Tree</title>
  <link rel="stylesheet" href="../css/main.css" />
  <link rel="stylesheet" href="../css/book.css" />
  <link rel="stylesheet" href="../css/code.css" />
  <link rel="stylesheet" href="../css/quiz.css" />
  <link rel="stylesheet" href="../css/mobile.css" />
  <link rel="stylesheet" href="../css/print.css" />
  
  <link rel="stylesheet" href="../lib/JSAV.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaMOD.css" type="text/css" />
  <link rel="stylesheet" href="../lib/jquery.ui.min.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaStyle.css" type="text/css" />
  <link rel="stylesheet" href="../lib/ChalmersGU-interactive.css" type="text/css" />

  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
      },
      "HTML-CSS": {
        scale: "80",
      }
    });
  </script>

  <script type="text/javascript" src="../lib/jquery.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.migrate.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src="../lib/localforage.min.js"></script>
  <script type="text/javascript" src="../lib/accessibility.js"></script>
  <script type="text/javascript" src="../lib/jquery.ui.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.transit.js"></script>
  <script type="text/javascript" src="../lib/raphael.js"></script>
  <script type="text/javascript" src="../lib/JSAV.js"></script>
  <script type="text/javascript" src="../lib/config.js"></script>
  <script type="text/javascript" src="../lib/timeme.js"></script>
  <script type="text/javascript" src="../lib/odsaUtils.js"></script>
  <script type="text/javascript" src="../lib/odsaMOD.js"></script>
  <script type="text/javascript" src="../lib/d3.min.js"></script>
  <script type="text/javascript" src="../lib/d3-selection-multi.v1.min.js"></script>
  <script type="text/javascript" src="../lib/dataStructures.js"></script>
  <script type="text/javascript" src="../lib/conceptMap.js"></script>

  <script>
    ODSA.SETTINGS.MODULE_SECTIONS = [
    'internal-variables', 
    'getting-and-setting-values', 
    'adding-elements', 
    'add-practice-exericse', 
    'removing-elements', 
    'remove-practice-exericise', 
    'static-array-based-list-summary-questions', 
    'static-array-based-list:-full-code',
    ];
    ODSA.SETTINGS.MODULE_NAME = "DSABook";
    ODSA.SETTINGS.MODULE_LONG_NAME = "Data Structures and Algorithms";
    JSAV_OPTIONS['lang']='en';
    JSAV_EXERCISE_OPTIONS['code']='pseudo';
  </script>

  
  <script type="text/javascript" src="../scripts/quizhandler.js"></script>
</head>

<body>

<header>
<nav class="sitenav">
<div></div>
<h1><a href="index.html" class="navbutton" accesskey="t" rel="top">Data Structures and Algorithms</a></h1>
<div></div>
</nav>
<nav class="sitenav">
<div>
<a href="6.3-balanced-trees.html" class="navbutton">&lt;&lt;</a>
<a href="6.3-balanced-trees.html" accesskey="p" rel="previous">Balanced Trees</a>
</div>
<div>
<a href="6.5-the-red-black-tree-optional.html" accesskey="n" rel="next">The Red-Black Tree (optional)</a>
<a href="6.5-the-red-black-tree-optional.html" class="navbutton">&gt;&gt;</a>
</div>
</nav>
</header>

<main>
<section id="the-avl-tree" class="level2" data-number="6.4">
<h2 data-number="6.4"><span class="header-section-number">6.4</span> The
AVL Tree</h2>
<p>The AVL tree is a BST with the following additional property: For
every node, the heights of its left and right subtrees differ by at most
1. As long as the tree maintains this property, if the tree contains
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
nodes, then it has a depth of at most
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math>.
As a result, search for any node will cost
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math>,
and if the updates can be done in time proportional to the depth of the
node inserted or deleted, then updates will also cost
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math>,
even in the worst case.</p>
<p>The key to making the AVL tree work is to alter the insert and delete
routines so as to maintain the balance property. Of course, to be
practical, we must be able to implement the revised update routines in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(\log n)</annotation></semantics></math>
time. To maintain the balance property, we are going to use what are
called <a href="10-glossary.html#rotation" class="term"
title="In the AVL tree and splay tree, a rotation is a local operation performed on a node, its children, and its grandchildren that can result in reordering their relationship. The goal of performing a rotation is to make the tree more balanced.">rotations</a>.</p>
<section id="rotations" class="level3" data-number="6.4.1">
<h3 data-number="6.4.1"><span class="header-section-number">6.4.1</span>
Rotations</h3>
<p>Rotation is an operation that takes a node in the tree and moves it
one level higher. <a href="6.4-the-avl-tree.html#SingleRotation">Figure
#SingleRotation</a> illustrates rotation. Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
are nodes, while
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
represent subtrees.</p>
<p>In Figure (a), node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
is the left child of the root. A <em>right rotation</em> transforms it
into the tree shown in Figure (b), where node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
has become the root. Note that, because the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
is less than the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
must become
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>’s
right child. Right rotation means transforming a tree from having the
shape in (a) to having the shape in (b).</p>
<p>A <em>left rotation</em> is the opposite process: starting from the
tree in (b), transforming it to the tree in (a), by lifting node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
up. Notice that a right rotation tends to make the tree more
right-leaning, while a left rotation tends to make it more
left-leaning.</p>
<div id="SingleRotation">
<div class="figure">
<figure>
<img src="images/SingRot.png" width="500" alt="Rotation" />
<figcaption aria-hidden="true">Rotation</figcaption>
</figure>
<p>In a rotation, node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
is promoted to the root, rotating with node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>.
Because the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
is less than the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
must become
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
’s right child. The positions of subtrees
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
are altered as appropriate to maintain the BST property, but the
contents of these subtrees remains unchanged. (a) The original tree with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
as the parent. (b) The tree after a rotation takes place.</p>
<p>Going from (a) to (b) is called a <em>right rotation</em>. We can
also go from (b) to (a) promoting node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
to the root – this is called a <em>left rotation</em>. In general, a
right rotation makes the tree more right-leaning, and a left rotation
makes it more left-leaning.</p>
</div>
</div>
</section>
<section id="avl-tree-insertion" class="level3" data-number="6.4.2">
<h3 data-number="6.4.2"><span class="header-section-number">6.4.2</span>
AVL tree insertion</h3>
<div id="AVLinsert">
<div class="figure">
<figure>
<img src="images/AVLins.png" width="500"
alt="An insertion that violates the AVL tree balance property" />
<figcaption aria-hidden="true">An insertion that violates the AVL tree
balance property</figcaption>
</figure>
<p>Example of an insert operation that violates the AVL tree balance
property. Prior to the insert operation, all nodes of the tree are
balanced (i.e., the depths of the left and right subtrees for every node
differ by at most one). After inserting the node with value 5, the nodes
with values 7 and 24 are no longer balanced.</p>
</div>
</div>
<p>Consider what happens when we insert a node with key value 5, as
shown in <a href="6.4-the-avl-tree.html#AVLinsert">Figure
#AVLinsert</a>. The tree on the left meets the AVL tree balance
requirements. After the insertion, two nodes no longer meet the
requirements. Because the original tree met the balance requirement,
nodes in the new tree can only be unbalanced by a difference of at most
2 in the subtrees. For the bottommost unbalanced node, call it
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>,
there are 4 cases:</p>
<ol type="1">
<li>The extra node is in the left child of the left child of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>.</li>
<li>The extra node is in the right child of the left child of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>.</li>
<li>The extra node is in the left child of the right child of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>.</li>
<li>The extra node is in the right child of the right child of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>.</li>
</ol>
<p>Cases 1 and 4 are symmetric, as are cases 2 and 3. Note also that the
unbalanced nodes must be on the path from the root to the newly inserted
node.</p>
<p>Our problem now is how to balance the tree in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math>
time. It turns out that we can do this using a series of rotations.
Cases 1 and 4 can be fixed using a <a
href="10-glossary.html#single-rotation" class="term"
title="A type of rebalancing operation used by the splay tree and AVL tree.">single
rotation</a>, as shown in <a
href="6.4-the-avl-tree.html#AVLsingle">Figure #AVLsingle</a>. Cases 2
and 3 can be fixed using a <a href="10-glossary.html#double-rotation"
class="term"
title="A type of rebalancing operation used by the splay tree and AVL tree.">double
rotation</a>, as shown in <a
href="6.4-the-avl-tree.html#AVLdouble">Figure #AVLdouble</a>.</p>
<div id="AVLsingle">
<div class="figure">
<figure>
<img src="images/AVLSingRot.png" width="500"
alt="AVL tree single rotation" />
<figcaption aria-hidden="true">AVL tree single rotation</figcaption>
</figure>
<p>A single rotation in an AVL tree. This operation occurs when the
excess node (in subtree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>)
is in the left child of the left child of the unbalanced node labeled
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>.
By rearranging the nodes as shown, we preserve the BST property, as well
as re-balance the tree to preserve the AVL tree balance property. The
case where the excess node is in the right child of the right child of
the unbalanced node is handled in the same way.</p>
</div>
</div>
<div id="AVLdouble">
<div class="figure">
<figure>
<img src="images/AVLDblRot.png" width="500"
alt="AVL tree double rotation" />
<figcaption aria-hidden="true">AVL tree double rotation</figcaption>
</figure>
<p>A double rotation in an AVL tree. This operation occurs when the
excess node (in subtree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>)
is in the right child of the left child of the unbalanced node labeled
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>.
By rearranging the nodes as shown, we preserve the BST property, as well
as re-balance the tree to preserve the AVL tree balance property. The
case where the excess node is in the left child of the right child of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
is handled in the same way.</p>
</div>
</div>
<p>The AVL tree insert algorithm begins with a normal BST insert. Then
as the recursion unwinds up the tree, we perform the appropriate
rotation on any node that is found to be unbalanced. Deletion is
similar; however, consideration for unbalanced nodes must begin at the
level of the <em>deleteMin</em> operation.</p>
<section id="example-33" class="level4 unnumbered topic">
<h4 class="unnumbered">Example</h4>
<p>In <a href="6.4-the-avl-tree.html#AVLinsert">Figure #AVLinsert</a>
(b), the bottom-most unbalanced node has value 7. The excess node (with
value 5) is in the right subtree of the left child of 7, so we have an
example of Case 2. This requires a double rotation to fix. After the
rotation, 5 becomes the left child of 24, 2 becomes the left child of 5,
and 7 becomes the right child of 5.</p>
</section>
<p>To try out AVL insertion yourself and see how it works, see <a
href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">AVL
Tree Visualization</a>. You can also find a few more examples under <a
href="https://bradfieldcs.com/algos/trees/avl-trees/">AVL Trees</a>.</p>
<p>Here is an implementation of AVL trees:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AVLNode:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    AVLNode(key, value):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.key <span class="op">=</span> key      <span class="co">// the key that are used for looking up values</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.value <span class="op">=</span> value  <span class="co">// the value associated with the key</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.left <span class="op">=</span> <span class="va">null</span>    <span class="co">// the left subtree, initially null</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.right <span class="op">=</span> <span class="va">null</span>   <span class="co">// the right subtree, initially null</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.height <span class="op">=</span> <span class="dv">1</span>     <span class="co">// the height of this subtree</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AVLMap <span class="kw">implements</span> <span class="bu">Map</span>:</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    AVLMap():</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.root <span class="op">=</span> <span class="va">null</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.treeSize <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">get</span>(key):</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Look up the value associated with a key.</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">this</span>.getHelper(<span class="va">this</span>.root, key)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    getHelper(node, key):</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// This is exactly the same as getHelper for BSTMap.</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">null</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">&lt;</span> node.key:</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">this</span>.getHelper(node.left, key)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">&gt;</span> node.key:</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">this</span>.getHelper(node.right, key)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> node.value</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">put</span>(key, value):</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Add a key-value pair, or update the value associated with an existing key. </span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">// This is the same as BSTMap.put, except that it rebalances the node afterwards.</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.root <span class="op">=</span> <span class="va">this</span>.putHelper(<span class="va">this</span>.root, key, value)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    putHelper(node, key, value):</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Recursive helper method for &#39;put&#39;, returns the updated node.</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>            <span class="va">this</span>.treeSize <span class="op">=</span> <span class="va">this</span>.treeSize <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">new</span> AVLNode(key, value)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">&lt;</span> node.key:</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>            node.left <span class="op">=</span> <span class="va">this</span>.putHelper(node.left, key, value)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>            <span class="va">this</span>.updateHeight(node)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">&gt;</span> node.key:</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>            node.right <span class="op">=</span> <span class="va">this</span>.putHelper(node.right, key, value)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>            <span class="va">this</span>.updateHeight(node)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="co">// key == node.key</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>            node.value <span class="op">=</span> value</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">this</span>.rebalance(node)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">remove</span>(key):</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Delete a key and its associated value.</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">// This is the same as BSTMap.remove, except that it rebalances the node afterwards.</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.root <span class="op">=</span> <span class="va">this</span>.removeHelper(<span class="va">this</span>.root, key)</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    removeHelper(node, key):</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Helper method for &#39;remove&#39;, returns the updated node.</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">null</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">&lt;</span> node.key:</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>            node.left <span class="op">=</span> <span class="va">this</span>.removeHelper(node.left, key)</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>            <span class="va">this</span>.updateHeight(node)</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">this</span>.rebalance(node)</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">&gt;</span> node.key:</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>            node.right <span class="op">=</span> <span class="va">this</span>.removeHelper(node.right, key)</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>            <span class="va">this</span>.updateHeight(node)</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">this</span>.rebalance(node)</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="co">// key == node.key</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node.left <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>                <span class="va">this</span>.treeSize <span class="op">=</span> <span class="va">this</span>.treeSize <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> node.right</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> node.right <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>                <span class="va">this</span>.treeSize <span class="op">=</span> <span class="va">this</span>.treeSize <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> node.left</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>                predecessor <span class="op">=</span> <span class="va">this</span>.largestNode(node.left)</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>                old_value <span class="op">=</span> node.value</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>                node.key <span class="op">=</span> predecessor.key</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>                node.value <span class="op">=</span> predecessor.value</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>                node.left <span class="op">=</span> <span class="va">this</span>.removeHelper(node.left, predecessor.key)</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>                <span class="va">this</span>.updateHeight(node)</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">this</span>.rebalance(node)</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>    getHeight(node):</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Return the height of a tree node, also works if the node is null.</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> node.height</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>    updateHeight(node):</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Recompute the value of the height of a tree node.</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Must be called every time the height could change.</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>        node.height <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">max</span>(<span class="va">this</span>.getHeight(node.left), <span class="va">this</span>.getHeight(node.right))</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>    heightDiff(node):</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Return the height difference of a node: left height - right height.</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">this</span>.getHeight(node.left) <span class="op">-</span> <span class="va">this</span>.getHeight(node.right)</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>    largestNode(node):</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Find the descendant node having the largest key.</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node.right <span class="kw">is</span> <span class="kw">not</span> <span class="va">null</span>:</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> node.right</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node</span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>    rebalance(node):</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">is</span> <span class="va">null</span>: </span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">null</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>        diff <span class="op">=</span> <span class="va">this</span>.heightDiff(node)</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> diff <span class="op">&gt;</span> <span class="dv">1</span>:  <span class="co">// Left-leaning</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>            leftDiff <span class="op">=</span> <span class="va">this</span>.heightDiff(node.left)</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> leftDiff <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:  <span class="co">// Left-right: convert to left-left</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>                node.left <span class="op">=</span> <span class="va">this</span>.rotateLeft(node.left)</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>                <span class="va">this</span>.updateHeight(node)</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">this</span>.rotateRight(node)</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> diff <span class="op">&lt;</span> <span class="op">-</span><span class="dv">1</span>:  <span class="co">// Right-leaning</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>            rightDiff <span class="op">=</span> <span class="va">this</span>.heightDiff(node.right)</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> rightDiff <span class="op">==</span> <span class="dv">1</span>:  <span class="co">// Right-left: convert to right-right</span></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>                node.right <span class="op">=</span> <span class="va">this</span>.rotateRight(node.right)</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>                <span class="va">this</span>.updateHeight(node)</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">this</span>.rotateLeft(node)</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> node</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>    rotateLeft(x):</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Left rotation.</span></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;&quot;&quot;      x                 y    </span></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a><span class="st">                 / \               / \   </span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a><span class="st">                A   y     ===&gt;    x   C  </span></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a><span class="st">                   / \           / \     </span></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a><span class="st">                  B   C         A   B         &quot;&quot;&quot;</span>)</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Variables are named according to the picture above.</span></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> x.right</span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>        B <span class="op">=</span> y.left</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>        x.right <span class="op">=</span> B</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>        y.left <span class="op">=</span> x</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>    rotateRight(x):</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Right rotation.</span></span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;&quot;&quot;       x              y</span></span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a><span class="st">                  / \            / </span><span class="ch">\</span></span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a><span class="st">                 y   C   ===&gt;   A   x</span></span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a><span class="st">                / \                / </span><span class="ch">\</span></span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a><span class="st">               A   B              B   C       &quot;&quot;&quot;</span>)</span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Variables are named according to the picture above.</span></span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> x.left</span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>        B <span class="op">=</span> y.right</span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>        x.left <span class="op">=</span> B</span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>        y.right <span class="op">=</span> x</span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y</span></code></pre></div>
</section>
</section>
</main>

<footer>
<nav class="sitenav">
<div class="navlink">
<a href="6.3-balanced-trees.html" class="navbutton">&lt;&lt;</a>
<a href="6.3-balanced-trees.html" accesskey="p" rel="previous">Balanced Trees</a>
</div>
<div class="navlink">
<a href="6.5-the-red-black-tree-optional.html" accesskey="n" rel="next">The Red-Black Tree (optional)</a>
<a href="6.5-the-red-black-tree-optional.html" class="navbutton">&gt;&gt;</a>
</div>
</nav>
</footer>

</body>
</html>

