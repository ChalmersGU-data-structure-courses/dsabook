<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Peter Ljunglöf" />
  <meta name="author" content="Alex Gerdes" />
  <meta name="author" content="(editors)" />
  <title>DSABook – Binary search trees</title>
  <link rel="stylesheet" href="../css/main.css" />
  <link rel="stylesheet" href="../css/book.css" />
  <link rel="stylesheet" href="../css/code.css" />
  <link rel="stylesheet" href="../css/math.css" />
  <link rel="stylesheet" href="../css/quiz.css" />
  <link rel="stylesheet" href="../css/mobile.css" />
  <link rel="stylesheet" href="../css/print.css" />
  <style id="dynamicStyleSheet"></style>
  
  <link rel="stylesheet" href="../lib/JSAV.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaMOD.css" type="text/css" />
  <link rel="stylesheet" href="../lib/jquery.ui.min.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaStyle.css" type="text/css" />

  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/javascript" src="../lib/jquery.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.migrate.min.js"></script>
  <script type="text/javascript" src="../lib/localforage.min.js"></script>
  <script type="text/javascript" src="../lib/accessibility.js"></script>
  <script type="text/javascript" src="../lib/jquery.ui.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.transit.js"></script>
  <script type="text/javascript" src="../lib/raphael.js"></script>
  <script type="text/javascript" src="../lib/JSAV.js"></script>
  <script type="text/javascript" src="../lib/config.js"></script>
  <script type="text/javascript" src="../lib/timeme.js"></script>
  <script type="text/javascript" src="../lib/odsaUtils.js"></script>
  <script type="text/javascript" src="../lib/odsaMOD.js"></script>
  <script type="text/javascript" src="../lib/d3.min.js"></script>
  <script type="text/javascript" src="../lib/d3-selection-multi.v1.min.js"></script>
  <script type="text/javascript" src="../lib/dataStructures.js"></script>
  <script type="text/javascript" src="../lib/conceptMap.js"></script>

  <script>
    ODSA.SETTINGS.MODULE_SECTIONS = [
    'internal-variables', 
    'getting-and-setting-values', 
    'adding-elements', 
    'add-practice-exericse', 
    'removing-elements', 
    'remove-practice-exericise', 
    'static-array-based-list-summary-questions', 
    'static-array-based-list:-full-code',
    ];
    ODSA.SETTINGS.MODULE_NAME = "DSABook";
    ODSA.SETTINGS.MODULE_LONG_NAME = "Data Structures and Algorithms";
    JSAV_OPTIONS['lang']='en';
    JSAV_EXERCISE_OPTIONS['code']='pseudo';
  </script>

  
  <script type="text/javascript" src="../scripts/quizhandler.js"></script>
<link href="../interactive/Binary/BSTCON.css" rel="stylesheet" type="text/css"/>
<link href="../interactive/Binary/BSTShapeCON.css" rel="stylesheet" type="text/css"/></head>

<body>

<header>
<nav class="sitenav">
<div></div>
<h1><a href="index.html" class="navbutton" accesskey="t" rel="top">Data Structures and Algorithms</a></h1>
<div></div>
</nav>
<nav class="sitenav">
<div>
<a href="section-11.html" class="navbutton">&lt;&lt;</a>
<a href="section-11.html" accesskey="p" rel="previous">Search trees</a>
</div>
<div>
<a href="section-11.2.html" accesskey="n" rel="next">Self-balancing trees</a>
<a href="section-11.2.html" class="navbutton">&gt;&gt;</a>
</div>
</nav>
</header>

<main>
<section id="sec:binary-search-trees" class="level2" data-number="11.1">
<h2 data-number="11.1"><span class="header-section-number">11.1</span>
Binary search trees</h2>
<p>A <a href="section-14.html#binary-search-tree" class="term"
title="A binary tree that imposes the following constraint on its node values: The search key value for any node $A$ must be greater than the (key) values for all nodes in the left subtree of $A$, and less than the key values for all nodes in the right subtree of $A$. Some convention must be adopted if multiple nodes with the same key value are permitted, typically these are required to be in the right subtree.">binary
search tree</a> (<a href="section-14.html#bst" class="term"
title="A binary tree that imposes the following constraint on its node values: The search key value for any node $A$ must be greater than the (key) values for all nodes in the left subtree of $A$, and less than the key values for all nodes in the right subtree of $A$. Some convention must be adopted if multiple nodes with the same key value are permitted, typically these are required to be in the right subtree.">BST</a>)
is a <a href="section-14.html#binary-tree" class="term"
title="A finite set of nodes which is either empty, or else has a root node together two binary trees, called the left and right subtrees, which are disjoint from each other and from the root.">binary
tree</a> that conforms to the following condition, known as the <a
href="section-14.html#binary-search-tree-property" class="term"
title="The defining relationship between the key values for nodes in a BST. All nodes stored in the left subtree of a node whose key value is $K$ have key values less than or equal to $K$. All nodes stored in the right subtree of a node whose key value is $K$ have key values greater than $K$.">binary
search tree property</a>:</p>
<blockquote>
<p>All <a href="section-14.html#node" class="term"
title="The objects that make up a linked structure such as a linked list or binary tree. Typically, nodes are allocated using dynamic memory allocation. In graph terminology, the nodes are more commonly called vertices.">nodes</a>
stored in the left subtree of a node whose <a href="section-14.html#key"
class="term"
title="A field or part of a larger record used to represent that record for the purpose of searching or comparing. Another term for search key.">key</a>
value is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
have key values less than or equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>.
All nodes stored in the right subtree of a node whose key value is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
have key values greater than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>.</p>
</blockquote>
<p><a href="#fig:BSTShape">Figure 11.1</a> below shows two BSTs for a
collection of values. One consequence of the binary search tree property
is that if the BST nodes are printed using an <a
href="section-14.html#inorder-traversal" class="term"
title="In a binary tree, a traversal that first recursively visits the left child, then visits the root, and then recursively visits the right child. In a binary search tree, this traversal will enumerate the nodes in sorted order.">inorder
traversal</a>, then the resulting enumeration will be in sorted order
from lowest to highest.</p>
<figure id="fig:BSTShape">

<div id="BSTShapeCON" class="ssAV" data-short-name="BSTShapeCON" data-long-name="BSTShapeCON" alt="BSTShapeCON" tabIndex="-1">
<div class="jsavcanvas"></div>
</div>

<script type="text/javascript" src="../interactive/Binary/BSTShapeCON.js"></script>
<script>
  $(document).ready(function(){
    function NewAV() {return new JSAV("BSTShapeCON", {animationMode: "none"})}
    function AddCSS(rule) {document.getElementById("dynamicStyleSheet").sheet.insertRule("#BSTShapeCON "+rule)}
    
  });
</script>

<figcaption><p>Figure 11.1: Two Binary Search Trees for a collection of
values. Tree (a) results if values are inserted in the order 37, 24, 42,
120, 32, 7. Tree (b) results if the same values are inserted in the
order 7, 37, 42, 32, 120, 24.</p></figcaption>
</figure>
<p>The only thing that differentiates a BST from a normal binary tree is
the BST property. This property is an <em>invariant</em>, as as
explained in <a
href="section-2.2.html#sec:invariants-preconditions-and-postconditions">Section 2.2</a>,
and it is a condition that the BST <em>always</em> must satisfy.</p>
<p>Invariants are not stored in the datatype, so the actual declaration
for a BST is exactly the same as a normal binary tree:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> BST:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    root: BinaryNode <span class="op">=</span> <span class="va">null</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">size</span>: <span class="bu">Int</span> <span class="op">=</span> <span class="dv">0</span></span></code></pre></div>
<p>The BST property is therefore not explicit in the datatype
declaration, but instead it is something that all operations must
satisfy. Whenever we implement a new operation, we have to make sure
that we never break the property.</p>
<section id="sec:searching-in-a-bst" class="level4 unnumbered">
<h4 class="unnumbered">Searching in a BST</h4>
<p>Because of the BST property, we don’t have to search the whole tree
if we want to find an element. Instead, we can start at the root node
and compare its value with the value we are searching for. If the value
is smaller than the root, we know that we can disregard everything in
the right subtree. (And conversely, if the value is larger, we can
disregard the left subtree.)</p>
<p>Now, assuming that the value was smaller than the root, we can go to
the left child and compare again. If the value now is larger than the
child, we can continue into the child’s right subtree. We continue this
until we have found the value in a node, or until we reach an empty
child. If we reach an empty child we know that the value is not in the
tree. Here is a possible implementation of a method that returns true if
the element is in the tree:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> BST:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">contains</span>(elem):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> root</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node <span class="kw">is</span> <span class="kw">not</span> <span class="va">null</span>:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> elem <span class="op">==</span> node.elem:</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">true</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> elem <span class="op">&lt;</span> node.elem:</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> node.left</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> elem <span class="op">&gt;</span> node.elem:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> node.right</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">false</span></span></code></pre></div>
</section>
<section id="sec:inserting-into-a-bst" class="level4 unnumbered">
<h4 class="unnumbered">Inserting into a BST</h4>
<p>When we want to insert an element we first have to search for it,
similar to what we did above. If it already exists we don’t have to do
anything, and if it isn’t in the tree we create a new node and attach it
to the right place. But how do we know where to add the new node? The
variable <code>node</code> becomes null if the element isn’t found, so
we have nothing to attach the node to – instead we want to attach the
new node to the <em>previous</em> tree node that we looked at. The
solution is to add another temporary variable, <code>parent</code>,
which points to the parent of <code>node</code> – i.e., its value in the
previous iteration.</p>
<p>Now, after we have completed the search, and the element wasn’t
found, we can simply create a new node and attach it as a child to
<code>parent</code>. Depending on if the element is smaller or larger
than the parent element, we make it a left or right child.
Alternatively, if the tree is empty then we have to attach the new node
directly to the root.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> BST:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">add</span>(elem):</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Search for the parent of the new node.</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        parent <span class="op">=</span> <span class="va">null</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> root</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node <span class="kw">is</span> <span class="kw">not</span> <span class="va">null</span>:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            parent <span class="op">=</span> node</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> elem <span class="op">==</span> node.elem</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span>  <span class="co">// The element is already in the BST, so we do nothing.</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> elem <span class="op">&lt;</span> node.elem:</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> node.left</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> elem <span class="op">&gt;</span> node.elem:</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> node.right</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Create a new node and attach it to the parent.</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> <span class="kw">new</span> BinaryNode(elem)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> parent <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            root <span class="op">=</span> node  <span class="co">// The tree is empty, so we update the root.</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> elem <span class="op">&lt;</span> parent.elem:</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            parent.left <span class="op">=</span> node</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> elem <span class="op">&gt;</span> parent.elem:</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>            parent.right <span class="op">=</span> node</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">size</span> <span class="op">=</span> <span class="bu">size</span> <span class="op">+</span> <span class="dv">1</span></span></code></pre></div>
<p>We have to decide what to do when the node that we want to insert has
a key value equal to the key of some node already in the tree. If during
insert we find a node that duplicates the key value to be inserted, then
we have two options. If the application does not allow nodes with equal
keys, then this insertion should be treated as an error (or ignored). If
duplicate keys are allowed, our convention will be to insert the
duplicate in the left subtree.</p>
<p>The shape of a BST depends on the order in which elements are
inserted. A new element is added to the BST as a new leaf node,
potentially increasing the depth of the tree. <a
href="#fig:BSTShape">Figure 11.1</a> illustrates two BSTs for a
collection of values. It is possible for the BST containing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
nodes to be a chain of nodes with height
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>.
This would happen if, for example, all elements were inserted in sorted
order. In general, it is preferable for a BST to be as shallow as
possible. This keeps the average cost of a BST operation low.</p>
</section>
<section id="sec:recursive-search-and-insert" class="level3"
data-number="11.1.1">
<h3 data-number="11.1.1"><span
class="header-section-number">11.1.1</span> Recursive search and
insert</h3>
<p>Bot searching and insertion can be implemented as recursive function
too, and it is instructive to see how to to that. And since we showed
the <em>set</em> operations <code>contains</code> and <code>add</code>
above, we will show how to implement recursive versions of the
<em>map</em> operations <code>get</code> and <code>put</code>.</p>
<div class="online">
<p>Note that this means that our binary tree nodes will have the
instance variables <em>key</em> and <em>value</em>, instead of the
single <em>elem</em> that we used earlier.</p>
<section id="sec:getting-the-value-for-a-key" class="level4 unnumbered">
<h4 class="unnumbered">Getting the value for a key</h4>
<p>First we will look at the <code>get</code> operation for finding the
record that matches a given key. To accomplish this we need a recursive
helper function which takes a node as argument, and we start by calling
this function with the root:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> BSTMap <span class="kw">implements</span> <span class="bu">Map</span>:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">get</span>(key):</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> getHelper(root, key)</span></code></pre></div>
<p>The function <code>getHelper</code> performs the same iteration as we
did earlier with <code>contains</code>, but implicitly as recursive
calls. When the key is found it returns the value of the node, and if
the key doesn’t exist it returns null:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    getHelper(node, key):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">null</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">&lt;</span> node.key:</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> getHelper(node.left, key)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">&gt;</span> node.key:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> getHelper(node.right, key)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">==</span> node.key:</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> node.value</span></code></pre></div>
<div class="dsvis">
<details open="true">
<summary>
<p>Here is an interactive explanation of searching in a BST.</p>
</summary>

<div id="BSTsearchCON" class="ssAV" data-short-name="BSTsearchCON" data-long-name="BST Search Slideshow" alt="BST Search Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>

<script type="text/javascript" src="../interactive/Binary/BSTsearchCON.js"></script>
<script>
  $(document).ready(function(){
    function NewAV() {return new JSAV("BSTsearchCON", {animationMode: "none"})}
    function AddCSS(rule) {document.getElementById("dynamicStyleSheet").sheet.insertRule("#BSTsearchCON "+rule)}
    
  });
</script>

</details>
</div>
<div class="dsvis">
<details open="true">
<summary>
<p>Here is an exercise on the BST search algorithm.</p>
</summary>

<div id="BSTsearchPRO" class="embedContainer">
<iframe id="BSTsearchPRO_iframe" aria-label="BSTsearchPRO" src="../interactive/Binary/BSTsearchPRO.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>

</details>
</div>
</section>
<section id="sec:setting-the-value-for-a-key" class="level4 unnumbered">
<h4 class="unnumbered">Setting the value for a key</h4>
<p>Now we look at how to set the value of a key. Yet again we need a
recursive helper function which we call with the root of the tree. This
function returns a pointer to the updated tree, and we have to make sure
to update the root to this updated tree.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> BSTMap <span class="kw">implements</span> <span class="bu">Map</span>:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">put</span>(key, value):</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        root <span class="op">=</span> putHelper(root, key, value)</span></code></pre></div>
<p>We do the same as for <code>getHelper</code> as for
<code>putHelper</code> above, but we have to update the value of each
child pointer in the path to be the new updated tree.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    putHelper(node, key, value):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>            <span class="bu">size</span> <span class="op">=</span> <span class="bu">size</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">new</span> BSTNode(key, value)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">&lt;</span> node.key:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>            node.left <span class="op">=</span> putHelper(node.left, key, value)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">&gt;</span> node.key:</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>            node.right <span class="op">=</span> putHelper(node.right, key, value)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">==</span> node.key:</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            node.value <span class="op">=</span> value</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node</span></code></pre></div>
<div class="dsvis">
<details open="true">
<summary>
<p>Here is an interactive explanation of recursive insertion.</p>
</summary>

<div id="BSTinsertCON" class="ssAV" data-short-name="BSTinsertCON" data-long-name="BST Insert Slideshow" alt="BST Insert Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>

<script type="text/javascript" src="../interactive/Binary/BSTinsertCON.js"></script>
<script>
  $(document).ready(function(){
    function NewAV() {return new JSAV("BSTinsertCON", {animationMode: "none"})}
    function AddCSS(rule) {document.getElementById("dynamicStyleSheet").sheet.insertRule("#BSTinsertCON "+rule)}
    
  });
</script>

</details>
</div>
<p>Note that, except for the last node in the path,
<code>putHelper</code> will not actually change the child pointer for
any of the nodes that are visited. In that sense, many of the
assignments seem redundant. However, the cost of these additional
assignments is worth paying to keep the insertion process simple. The
alternative is to check if a given assignment is necessary, which is
probably more expensive than the assignment!</p>
<div class="dsvis">
<details open="true">
<summary>
<p>Here is an exercise on BST insertion.</p>
</summary>

<div id="BSTinsertPRO" class="embedContainer">
<iframe id="BSTinsertPRO_iframe" aria-label="BSTinsertPRO" src="../interactive/Binary/BSTinsertPRO.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>

</details>
</div>
</section>
</div>
</section>
<section id="sec:removing-from-a-bst" class="level3"
data-number="11.1.2">
<h3 data-number="11.1.2"><span
class="header-section-number">11.1.2</span> Removing from a BST</h3>
<p>Removing a node from a BST is a bit trickier than inserting a node,
but it is not complicated if all of the possible cases are considered
individually. Before tackling the general node removal process, we need
a useful companion method, <code>largestNode</code>, which returns a
pointer to the node containing the maximum value in a subtree.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> largestNode(node):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> node.right <span class="kw">is</span> <span class="kw">not</span> <span class="va">null</span>:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> node.right</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> node</span></code></pre></div>
<p>This time we will show a <em>recursive</em> implementation of
<code>remove</code>. For this we need a recursive helper function which
we initially call with the root of the tree.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> BSTMap:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">remove</span>(key):</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        root <span class="op">=</span> removeHelper(root, key)</span></code></pre></div>
<p>Now we are ready for the <code>removeHelper</code> method. Removing a
node with given key value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
from the BST requires that we first find
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
and then remove it from the tree. So, the first part of the remove
operation is a search to find
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>.
Once
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
is found, there are several possibilities. If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
has no children, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>’s
parent has its pointer set to <strong>null</strong>. If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
has one child, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>’s
parent has its pointer set to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>’s
child. The problem comes if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
has two children. One simple approach, though expensive, is to set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>’s
parent to point to one of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>’s
subtrees, and then reinsert the remaining subtree’s nodes one at a time.
A better alternative is to find a value in one of the subtrees that can
replace the value in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>.</p>
<p>Thus, the question becomes: Which value can substitute for the one
being removed? It cannot be any arbitrary value, because we must
preserve the BST property without making major changes to the structure
of the tree. Which value is most like the one being removed? The answer
is the least key value greater than the one being removed, or else the
greatest key value less than (or equal to) the one being removed. If
either of these values replace the one being removed, then the BST
property is maintained.</p>
<div class="online">
<div class="dsvis">
<details open="true">
<summary>
<p>Here is an interactive explanation of BST deletion.</p>
</summary>

<div id="BSTremoveCON" class="ssAV" data-short-name="BSTremoveCON" data-long-name="BST Remove Slideshow" alt="BST Remove Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>

<script type="text/javascript" src="../interactive/Binary/BSTremoveCON.js"></script>
<script>
  $(document).ready(function(){
    function NewAV() {return new JSAV("BSTremoveCON", {animationMode: "none"})}
    function AddCSS(rule) {document.getElementById("dynamicStyleSheet").sheet.insertRule("#BSTremoveCON "+rule)}
    
  });
</script>

</details>
</div>
</div>
<p>When duplicate node values do not appear in the tree, it makes no
difference whether the replacement is the greatest value from the left
subtree or the least value from the right subtree. If duplicates are
stored in the left subtree, then we must select the replacement from the
<em>left</em> subtree. To see why, call the least value in the right
subtree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>.
If multiple nodes in the right subtree have value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>,
selecting
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
as the replacement value for the root of the subtree will result in a
tree with equal values to the right of the node now containing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>.
Selecting the greatest value from the left subtree does not have a
similar problem, because it does not violate the Binary Search Tree
Property if equal values appear in the left subtree.</p>
<div class="note">
<p><em>Note</em>: Alternatively, we can decide to store duplicate values
in the right subtree instead of the left. Then we must replace a deleted
node with the least value from its right subtree.</p>
</div>
<p>The code for removal is shown here. Note that the helper function
returns the updated subtree, and we have to make sure to update the
child pointers to this updated tree.<br />
</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    removeHelper(node, key):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">null</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">&lt;</span> node.key:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>            node.left <span class="op">=</span> removeHelper(node.left, key)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> node</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">&gt;</span> node.key:</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>            node.right <span class="op">=</span> removeHelper(node.right, key)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> node</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> key <span class="op">==</span> node.key:</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node.left <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>                <span class="bu">size</span> <span class="op">=</span> <span class="bu">size</span> <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> node.right</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> node.right <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>                <span class="bu">size</span> <span class="op">=</span> <span class="bu">size</span> <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> node.left</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>                predecessor <span class="op">=</span> largestNode(node.left)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>                node.key <span class="op">=</span> predecessor.key</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>                node.value <span class="op">=</span> predecessor.value</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>                node.left <span class="op">=</span> removeHelper(node.left, predecessor.key)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> node</span></code></pre></div>
<div class="online">
<div class="sourceCode" id="cb11"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> BSTMap:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">remove</span>(key):</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        parent <span class="op">=</span> <span class="va">null</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> root</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> node <span class="kw">is</span> <span class="kw">not</span> <span class="va">null</span>:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            parent <span class="op">=</span> node</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> key <span class="op">&lt;</span> node.key:</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> node.left</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> key <span class="op">&gt;</span> node.key:</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> node.right</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>: <span class="co">// key == node.key</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span>  <span class="co">// we found the key so break out of the loop</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span>  <span class="co">// the key is not in the tree, so do nothing</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// node to be deleted has at most one child</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node.left <span class="kw">is</span> <span class="va">null</span> <span class="kw">or</span> node.right <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">// newNode will replace the node to be deleted</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node.left <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>                newNode <span class="op">=</span> node.right</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>: <span class="co">// node.right is null</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>                newNode <span class="op">=</span> node.left</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> parent <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>                root <span class="op">=</span> newNode  <span class="co">// the node to be deleted is the root, so update the root</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> node <span class="op">==</span> parent.left:</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>                parent.left <span class="op">=</span> newNode  <span class="co">// node is a left child, so make newNode a left child</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>: <span class="co">// node == parent.right</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>                parent.right <span class="op">=</span> newNode  <span class="co">// node is a right child, so make newNode a right child</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> None</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">// node to be deleted has two children</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>            predecessorParent <span class="op">=</span> <span class="va">null</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>            predecessor <span class="op">=</span> node.left</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> predecessor.right <span class="kw">is</span> <span class="kw">not</span> <span class="va">null</span>:</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>                predecessorParent <span class="op">=</span> predecessor</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>                predecessor <span class="op">=</span> predecessor.right</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>            node.key <span class="op">=</span> predecessor.key</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>            node.value <span class="op">=</span> predecessor.value</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> predecessorParent <span class="kw">is</span> <span class="va">null</span>:</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>                node.left <span class="op">=</span> predecessor.left</span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>                predecessorParent.right <span class="op">=</span> predecessor.left</span></code></pre></div>
<div class="dsvis">
<details open="true">
<summary>
<p>Here is an exercise on BST deletion.</p>
</summary>

<div id="BSTremovePRO" class="embedContainer">
<iframe id="BSTremovePRO_iframe" aria-label="BSTremovePRO" src="../interactive/Binary/BSTremovePRO.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>

</details>
</div>
</div>
</section>
<section id="sec:analysis" class="level3" data-number="11.1.3">
<h3 data-number="11.1.3"><span
class="header-section-number">11.1.3</span> Analysis</h3>
<p>The cost for <code>contains</code>, <code>get</code>,
<code>add</code>, and <code>put</code> is the depth of the node found or
inserted. The cost for <code>remove</code> is the depth of the node
being removed, or in the case when this node has two children, the depth
of the node with smallest value in its right subtree. Thus, in the worst
case, the cost for any one of these operations is the depth of the
deepest node in the tree. This is why it is desirable to keep BSTs <a
href="section-14.html#balanced-tree" class="term"
title="A tree where the subtrees meet some criteria for being balanced. Two possibilities are that the tree is height balanced, or that the tree has a roughly equal number of nodes in each subtree.">balanced</a>,
that is, with least possible height. If a binary tree is balanced, then
the height for a tree of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
nodes is approximately
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math>.
However, if the tree is completely unbalanced, for example in the shape
of a linked list, then the height for a tree with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
nodes can be as great as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>.
Thus, a balanced BST will in the average case have operations costing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math>,
while a badly unbalanced BST can have operations in the worst case
costing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math>.
Consider the situation where we construct a BST of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
nodes by inserting records one at a time. If we are fortunate to have
them arrive in an order that results in a balanced tree (a “random”
order is likely to be good enough for this purpose), then each insertion
will cost on average
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math>,
for a total cost of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math>.
However, if the records are inserted in order of increasing value, then
the resulting tree will be a chain of height
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>.
The cost of insertion in this case will be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>i</mi><mo>∈</mo><mi>O</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{n} i \in O(n^2)</annotation></semantics></math>.</p>
<p>Traversing a BST costs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math>
regardless of the shape of the tree. Each node is visited exactly once,
and each child pointer is followed exactly once. For example, if we want
to print the nodes in ascending order we can perform an inorder
traversal (<a
href="section-8.4.html#sec:traversing-a-binary-tree">Section 8.4</a>),
which then will take time linear in the size of the tree.</p>
<p>While the BST is simple to implement and efficient when the tree is
balanced, the possibility of its being unbalanced is a serious
liability. There are techniques for organising a BST to guarantee good
performance. Two examples are the <a href="section-14.html#avl-tree"
class="term"
title="A variant implementation for the BST, which differs from the standard BST in that it uses modified insert and remove methods in order to keep the tree balanced. Similar to a splay tree in that it uses the concept of rotations in the insert and remove operations.">AVL
tree</a> (see <a
href="section-11.3.html#sec:avl-trees">Section 11.3</a>) and the <a
href="section-14.html#splay-tree" class="term"
title="A variant implementation for the BST, which differs from the standard BST in that it uses modified insert and remove methods in order to keep the tree balanced. Similar to an AVL tree in that it uses the concept of rotations in the insert and remove operations. While a splay tree does not guarentee that the tree is balanced, it does guarentee that a series of $n$ operations on the tree will have a total cost of $O(n \log n)$ cost, meaning that any given operation can be viewed as having amortised cost of $O(\log n)$.">splay
tree</a> (see <a
href="section-11.4.html#sec:splay-trees">Section 11.4</a>). There also
exist other types of search trees that are guaranteed to remain
balanced, such as the <a href="section-14.html#red-black-tree"
class="term" title="A balanced variation on a BST.">red-black tree</a>
or the <a href="section-14.html#2-3-tree" class="term"
title="A specialised form of the B-tree where each internal node has either 2 children or 3 children. Key values are ordered to maintain the binary search tree property. The 2-3 tree is always height balanced, and its insert, search, and remove operations all have $O(\log n)$ cost.">2-3
Tree</a>.</p>
</section>
<section id="sec:guided-information-flow" class="level3"
data-number="11.1.4">
<h3 data-number="11.1.4"><span
class="header-section-number">11.1.4</span> Guided information flow</h3>
<p>When writing a recursive method to solve a problem that requires
traversing a binary tree, we want to make sure that we are visiting the
required nodes (no more and no less).</p>
<p>So far, we have seen several tree traversals that visited every node
of the tree. We also saw the BST search, insert, and remove routines,
that each go down a single path of the tree. <a
href="section-14.html#guided-traversal" class="term"
title="A tree traversal that does not need to visit every node in the tree. An example would be a range query in a BST.">Guided
traversal</a> refers to a problem that does not require visiting every
node in the tree, though it typically requires looking at more than one
path through the tree. This means that the recursive function is making
some decision at each node that sometimes lets it avoid visiting one or
both of its children. The decision is typically based on the value of
the current node. Many problems that require information flow on binary
search trees are “guided” in this way.</p>
<section id="sec:example-minimum-value-in-a-tree"
class="level4 unnumbered example">
<h4 class="unnumbered">Example: Minimum value in a tree</h4>
<p>An extreme example is finding the minimum value in a BST. A bad
solution to this problem would visit every node of the tree. However, we
can take advantage of the BST property to avoid visiting most nods in
the tree. You know that the values greater than the root are always in
the right subtree, and those values less than the root are in the left
subtree. Thus, at each node we need only visit the left subtree until we
reach a leaf node.</p>
</section>
<div class="dsvis">
<details open="true">
<summary>
<p>Here is a problem that typically needs to visit more than just a
single path, but not all of the nodes.</p>
</summary>

<div id="IneffBinaryTreeRangeCON" class="ssAV" data-short-name="IneffBinaryTreeRangeCON" data-long-name="Inefficient Binary Tree Traversal on Range Slide Show" alt="Inefficient Binary Tree Traversal on Range Slide Show" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>

<script type="text/javascript" src="../interactive/Binary/IneffBinaryTreeRangeCON.js"></script>
<script>
  $(document).ready(function(){
    function NewAV() {return new JSAV("IneffBinaryTreeRangeCON", {animationMode: "none"})}
    function AddCSS(rule) {document.getElementById("dynamicStyleSheet").sheet.insertRule("#IneffBinaryTreeRangeCON "+rule)}
    
  });
</script>

</details>
</div>
</section>
</section>
</main>

<footer>
<nav class="sitenav">
<div class="navlink">
<a href="section-11.html" class="navbutton">&lt;&lt;</a>
<a href="section-11.html" accesskey="p" rel="previous">Search trees</a>
</div>
<div class="navlink">
<a href="section-11.2.html" accesskey="n" rel="next">Self-balancing trees</a>
<a href="section-11.2.html" class="navbutton">&gt;&gt;</a>
</div>
</nav>
</footer>

</body>
</html>


