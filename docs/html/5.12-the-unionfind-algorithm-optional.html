<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Cliff Shaffer" />
  <meta name="author" content="Peter Ljunglöf" />
  <meta name="author" content="Nick Smallbone" />
  <title>DSABook – The Union/Find Algorithm (optional)</title>
  <link rel="stylesheet" href="../css/main.css" />
  <link rel="stylesheet" href="../css/book.css" />
  <link rel="stylesheet" href="../css/code.css" />
  <link rel="stylesheet" href="../css/quiz.css" />
  <link rel="stylesheet" href="../css/mobile.css" />
  <link rel="stylesheet" href="../css/print.css" />
  
  <link rel="stylesheet" href="../lib/JSAV.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaMOD.css" type="text/css" />
  <link rel="stylesheet" href="../lib/jquery.ui.min.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaStyle.css" type="text/css" />
  <link rel="stylesheet" href="../lib/ChalmersGU-interactive.css" type="text/css" />

  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
      },
      "HTML-CSS": {
        scale: "80",
      }
    });
  </script>

  <script type="text/javascript" src="../lib/jquery.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.migrate.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src="../lib/localforage.min.js"></script>
  <script type="text/javascript" src="../lib/accessibility.js"></script>
  <script type="text/javascript" src="../lib/jquery.ui.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.transit.js"></script>
  <script type="text/javascript" src="../lib/raphael.js"></script>
  <script type="text/javascript" src="../lib/JSAV.js"></script>
  <script type="text/javascript" src="../lib/config.js"></script>
  <script type="text/javascript" src="../lib/timeme.js"></script>
  <script type="text/javascript" src="../lib/odsaUtils.js"></script>
  <script type="text/javascript" src="../lib/odsaMOD.js"></script>
  <script type="text/javascript" src="../lib/d3.min.js"></script>
  <script type="text/javascript" src="../lib/d3-selection-multi.v1.min.js"></script>
  <script type="text/javascript" src="../lib/dataStructures.js"></script>
  <script type="text/javascript" src="../lib/conceptMap.js"></script>

  <script>
    ODSA.SETTINGS.MODULE_SECTIONS = [
    'internal-variables', 
    'getting-and-setting-values', 
    'adding-elements', 
    'add-practice-exericse', 
    'removing-elements', 
    'remove-practice-exericise', 
    'static-array-based-list-summary-questions', 
    'static-array-based-list:-full-code',
    ];
    ODSA.SETTINGS.MODULE_NAME = "DSABook";
    ODSA.SETTINGS.MODULE_LONG_NAME = "Data Structures and Algorithms";
    JSAV_OPTIONS['lang']='en';
    JSAV_EXERCISE_OPTIONS['code']='pseudo';
  </script>

  
  <script type="text/javascript" src="../scripts/quizhandler.js"></script>
<link href="../interactive/General/UFCON.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<header>
<nav class="sitenav">
<div class="navlink"></div>
<h1 class="navlink navbutton"><a href="index.html" accesskey="t" rel="top">Data Structures and Algorithms</a></h1>
<div class="navlink"></div>
</nav>
<nav class="sitenav">
<div class="navlink">
<a href="5.11-general-trees-optional.html" class="navbutton">&lt;&lt;</a>
<a href="5.11-general-trees-optional.html" accesskey="p" rel="previous">General Trees (optional)</a>
</div>
<div class="navlink">
<a href="5.13-sequential-tree-representations-optional.html" accesskey="n" rel="next">Sequential Tree Representations (optional)</a>
<a href="5.13-sequential-tree-representations-optional.html" class="navbutton">&gt;&gt;</a>
</div>
</nav>
</header>

<main>
<section id="the-unionfind-algorithm-optional" class="level2"
data-number="5.12">
<h2 data-number="5.12"><span class="header-section-number">5.12</span>
The Union/Find Algorithm (optional)</h2>
<p><a href="10-glossary.html#general-tree" class="term"
title="A tree in which any given node can have any number of children. This is in contrast to, for example, a binary tree where each node has a fixed number of children (some of which might be `null`). General tree nodes tend to be harder to implement for this reason.">General
trees</a> are trees whose <a href="10-glossary.html#internal-node"
class="term"
title="In a tree, any node that has at least one non-empty child is an internal node.">internal
nodes</a> have no fixed number of <a href="10-glossary.html#child"
class="term"
title="In a tree, the set of nodes directly pointed to by a node $R$ are the children of $R$.">children</a>.
Compared to general trees, <a href="10-glossary.html#binary-tree"
class="term"
title="A finite set of nodes which is either empty, or else has a root node together two binary trees, called the left and right subtrees, which are disjoint from each other and from the root.">binary
trees</a> are relatively easy to implement because each internal node of
a binary tree can just store two pointers to reach its (potential)
children. In a general tree, we have to deal with the fact that a given
node might have no children or few children or many children.</p>
<p>Even in a general tree, each node can have only one <a
href="10-glossary.html#parent" class="term"
title="In a tree, the node $P$ that directly links to a node $A$ is the parent of $A$. $A$ is the child of $P$.">parent</a>.
If we didn’t need to go from a node to its children, but instead only
needed to go from a node to its parent, then implementing a node would
be easy. A simple way to represent such a general tree would be to store
for each node only a pointer to that node’s parent. We will call this
the <a href="10-glossary.html#parent-pointer-representation"
class="term"
title="For trees, a node implementation where each node stores only a pointer to its parent, rather than to its children. This makes it easy to go up the tree toward the root, but not down the tree toward the leaves. This is most appropriate for solving the UNION/FIND problem.">parent
pointer representation</a> for general trees. Clearly this
implementation is not general purpose, because it is inadequate for such
important operations as finding the leftmost child or the right sibling
for a node. Thus, it may seem to be a poor idea to implement a general
tree in this way. However, the parent pointer implementation stores
precisely the information required to answer the following, useful
question: <strong>Given two nodes, are they in the same tree?</strong>
To answer this question, we need only follow the series of parent
pointers from each node to its respective root. If both nodes reach the
same root, then they must be in the same tree. If the roots are
different, then the two nodes are not in the same tree. The process of
finding the ultimate root for a given node we will call <a
href="10-glossary.html#find" class="term"
title="One half of the UNION/FIND algorithm for managing disjoint sets. It is the process of moving upwards in a tree to find the tree&#39;s root.">FIND</a>.</p>
<section id="parent-pointer-trees" class="level3" data-number="5.12.1">
<h3 data-number="5.12.1"><span
class="header-section-number">5.12.1</span> Parent Pointer Trees</h3>
<p>The parent pointer representation is most often used to maintain a
collection of <a href="10-glossary.html#disjoint-sets" class="term"
title="A collection of sets, any pair of which share no elements in common. A collection of disjoint sets partitions some objects such that every object is in exactly one of the disjoint sets.">disjoint
sets</a>. Two disjoint sets share no members in common (their
intersection is empty). A collection of disjoint sets partitions some
objects such that every object is in exactly one of the disjoint sets.
There are two basic operations that we wish to support:</p>
<ol type="1">
<li>Determine if two objects are in the same set (the FIND operation),
and</li>
<li>Merge two sets together.</li>
</ol>
<p>Because two merged sets are united, the merging operation is called
<a href="10-glossary.html#union" class="term"
title="One half of the UNION/FIND algorithm for managing disjoint sets. It is the process of merging two trees that are represented using the parent pointer representation by making the root for one of the trees set its parent pointer to the root of the other tree.">UNION</a>
and the whole process of determining if two objects are in the same set
and then merging the sets goes by the name <a
href="10-glossary.html#union-find" class="term"
title="A process for mainining a collection of disjoint sets. The FIND operation determines which disjoint set a given object resides in, and the UNION operation combines two disjoint sets when it is determined that they are members of the same equivalence class under some equivalence relation.">UNION/FIND</a>.</p>
<p>To implement UNION/FIND, we represent each disjoint set with a
separate general tree. Two objects are in the same disjoint set if they
are in the same tree. Every node of the tree (except for the root) has
precisely one parent. Thus, each node requires the same space to
represent it. The collection of objects is typically stored in an array,
where each element of the array corresponds to one object, and each
element stores the object’s value (or a pointer to the object). The
objects also correspond to nodes in the various disjoint trees (one tree
for each disjoint set), so we also store the parent value with each
object in the array. Those nodes that are the roots of their respective
trees store an appropriate indicator. Note that this representation
means that a single array is being used to implement a collection of
trees. This makes it easy to merge trees together with UNION
operations.</p>
<p>Here is an implementation for parent pointer trees and the UNION/FIND
process.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// General Tree implementation for UNION/FIND</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ParentPointerTree:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    ParentPointerTree(<span class="bu">size</span>):</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Each node is its own root to start</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.array <span class="op">=</span> <span class="kw">new</span> <span class="bu">Array</span>(<span class="bu">size</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="op">=</span> <span class="dv">0</span> <span class="kw">to</span> <span class="bu">size</span><span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">this</span>.array[i] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>  <span class="co">// We use -1 to say that this is a root</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Merge two subtrees if they are different:</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    UNION(a, b):</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        root1 <span class="op">=</span> <span class="va">this</span>.FIND(a)  <span class="co">// Find root of node a</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        root2 <span class="op">=</span> <span class="va">this</span>.FIND(b)  <span class="co">// Find root of node b</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> root1 <span class="op">!=</span> root2:    <span class="co">// Merge two trees</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            <span class="va">this</span>.array[root1] <span class="op">=</span> root2</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return the root of current&#39;s tree</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    FIND(current):</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">this</span>.array[current] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> self.array[current]</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> current  <span class="co">// Now we are at the root</span></span></code></pre></div>
<p>The <code>ParentPointerTree</code> class has an array where each
array position corresponds to one object in some collection. Each array
element stores the array index for its parent. There are two main
methods to implement. Method <code>UNION</code> merges two sets
together, where each set corresponds to a tree. Method <code>FIND</code>
is used to find the ultimate root for a node.</p>
<p>An application using the UNION/FIND operations should store a set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
objects, where each object is assigned a unique index in the range 0 to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>.
The indices refer to the corresponding parent pointers in the array.
Class <code>ParentPointerTree</code> creates and initializes the
UNION/FIND array, and methods <code>UNION</code> and <code>FIND</code>
take array indices as inputs.</p>
<div id="UFfig">
<p>
<div id="UFfigCON" class="ssAV" data-short-name="UFfigCON" data-long-name="General/UFfigCON" alt="General/UFfigCON" tabIndex="-1">
<div class="jsavcanvas"></div>
</div>
</p>
<p>The parent pointer array implementation. Each node corresponds to a
position in the node array, which stores its value and a pointer to its
parent. The parent pointers are represented by an array index
corresponding to the position of the parent. The root of any tree stores
a special value, such as -1. This is represented graphically in the
figure by a slash in the “Parent’s Index” box. This figure shows two
trees stored in the same parent pointer array, one rooted at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
(with a total of 9 nodes), and the other rooted at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
(with a total of 1 node).</p>
</div>
</section>
<section id="equivalence-classes" class="level3" data-number="5.12.2">
<h3 data-number="5.12.2"><span
class="header-section-number">5.12.2</span> Equivalence Classes</h3>
<p>Consider the problem of assigning the members of a set to disjoint
subsets called <a href="10-glossary.html#equivalence-class" class="term"
title="An equivalence relation can be used to partition a set into equivalence classes.">equivalence
classes</a>. Recall that an <a
href="10-glossary.html#equivalence-relation" class="term"
title="Relation $R$ is an equivalence relation on set $\mathbf{S}$ if it is reflexive, symmetric, and transitive.">equivalence
relation</a> is <a href="10-glossary.html#reflexive" class="term"
title="In set notation, binary relation $R$ on set $S$ is reflexive if $aRa$ for all $a \in \mathbf{S}$.">reflexive</a>,
<a href="10-glossary.html#symmetric" class="term"
title="In set notation, relation $R$ is symmetric if whenever $aRb$, then $bRa$, for all $a, b \in \mathbf{S}$.">symmetric</a>,
and <a href="10-glossary.html#transitive" class="term"
title="In set notation, relation $R$ is transitive if whenever $aRb$ and $bRc$, then $aRc$, for all $a, b, c \in \mathbf{S}$.">transitive</a>.
Thus, if objects
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
are equivalent, and objects
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
are equivalent, then we must be able to recognize that objects
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
are also equivalent. In this representation, since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
are equivalent, they must be in the same tree. Likewise for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>.
We can recognize that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
are equivalent because they must also be in the same tree.</p>
<p>There are many practical uses for disjoint sets and representing
equivalences. For example, consider this graph of ten nodes labeled
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
through
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>.</p>
<div id="UFconcom">
<p>
<div id="UFconcomCON" class="ssAV" data-short-name="UFconcomCON" data-long-name="General/UFconcomCON" alt="General/UFconcomCON" tabIndex="-1">
<div class="jsavcanvas"></div>
</div>
</p>
<p>A graph with two connected components. The tree of <a
href="5.12-the-unionfind-algorithm-optional.html#UFfig">Figure
#UFfig</a> shows the corresponding tree structure resulting form
processing the edges to determine the connected components.</p>
</div>
<p>Notice that for nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
through
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>,
there is some series of edges that connects any pair of these nodes, but
node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
is disconnected from the rest of the nodes. Such a graph might be used
to represent connections such as wires between components on a circuit
board, or roads between cities. We can consider two nodes of the graph
to be equivalent if there is a path between them. Thus, nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi><annotation encoding="application/x-tex">E</annotation></semantics></math>
would be considered as equivalent, but
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
is not equivalent to any other. A subset of equivalent (connected) edges
in a graph is called a <a href="10-glossary.html#connected-component"
class="term"
title="In an undirected graph, a subset of the nodes such that each node in the subset can be reached from any other node in that subset.">connected
component</a>. The goal is to quickly classify the objects into disjoint
sets that correspond to the connected components.</p>
<p>Another use for UNION/FIND occurs in <a
href="9.6-minimal-cost-spanning-trees.html#kruskals-algorithm"
class="term"
title="An algorithm for computing the MCST of a graph. During processing, it makes use of the UNION/FIND process to efficiently determine of two vertices are within the same subgraph.">Kruskal’s
algorithm</a> for computing the <a
href="10-glossary.html#minimal-cost-spanning-tree" class="term"
title="Abbreviated as MCST, or sometimes as MST. Derived from a weighted graph, the MCST is the subset of the graph&#39;s edges that maintains the connectivitiy of the graph while having lowest total cost (as defined by the sum of the weights of the edges in the MCST). The result is referred to as a tree because it would never have a cycle (since an edge could be removed from the cycle and still preserve connectivity). Two algorithms to solve this problem are Prim&#39;s algorithm and Kruskal&#39;s algorithm.">minimal-cost
spanning tree</a> for a <a href="10-glossary.html#graph" class="term"
title="A graph $\mathbf{G} = (\mathbf{V}, \mathbf{E})$ consists of a set of vertices $\mathbf{V}$ and a set of edges $\mathbf{E}$, such that each edge in $\mathbf{E}$ is a connection between a pair of vertices in $\mathbf{V}$.">graph</a>.
That algorithm seeks to select the cheapest subset of the edges that
still connects all of the nodes in the graph. It does so by processing
all edges of the graph from shortest to longest, only adding an edge to
the connecting subset if it does not connect two nodes that already have
some series of edges connecting them.</p>
<p>The input to the UNION/FIND algorithm is typically a series of
equivalence pairs. In the case of the connected components example, the
equivalence pairs would simply be the set of edges in the graph. An
equivalence pair might say that object
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
is equivalent to object
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.
If so,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
are placed in the same subset. If a later equivalence relates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>,
then by implication
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
is also equivalent to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>.
Thus, an equivalence pair may cause two subsets to merge, each of which
contains several objects.</p>
<p>Equivalence classes can be managed efficiently with the UNION/FIND
algorithm. Initially, each object is at the root of its own tree. An
equivalence pair is processed by checking to see if both objects of the
pair are in the same tree by calling <code>FIND</code> on each of them.
If their roots are the same, then no change need be made because the
objects are already in the same equivalence class. Otherwise, the two
equivalence classes should be merged by the <code>UNION</code>
method.</p>
<p>The parent pointer representation places no limit on the number of
nodes that can share a parent. To make equivalence processing as
efficient as possible, the distance from each node to the root of its
respective tree should be as small as possible. Thus, we would like to
keep the height of the trees small when merging two equivalence classes
together. Ideally, each tree would have all nodes pointing directly to
the root. Achieving this goal all the time would require too much
additional processing to be worth the effort, so we must settle for
getting as close as possible.</p>
</section>
<section id="weighted-union" class="level3" data-number="5.12.3">
<h3 data-number="5.12.3"><span
class="header-section-number">5.12.3</span> Weighted Union</h3>
<p>A low-cost approach to reducing the height is to be smart about how
two trees are joined together. One simple technique, called the <a
href="10-glossary.html#weighted-union-rule" class="term"
title="When merging two disjoint sets using the UNION/FIND algorithm, the weighted union rule is used to determine which subtree&#39;s root points to the other. The root of the subtree with fewer nodes will be set to point to the root of the subtree with more nodes. In this way, the average depth of nodes in the resulting tree will be less than if the assignment had been made in the other direction.">weighted
union rule</a>, joins the tree with fewer nodes to the tree with more
nodes by making the smaller tree’s root point to the root of the bigger
tree. This will limit the total depth of the tree to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math>,
because the depth of nodes only in the smaller tree will now increase by
one, and the depth of the deepest node in the combined tree can only be
at most one deeper than the deepest node before the trees were combined.
The total number of nodes in the combined tree is therefore at least
twice the number in the smaller subtree. Thus, the depth of any node can
be increased at most
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math>
times when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
equivalences are processed (since each addition to the depth must be
accompanied by at least doubling the size of the tree).</p>
<p>Here is an implementation for the UNION method when using weighted
union.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ParentPointerTree:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    UNION(a, b):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        root1 <span class="op">=</span> <span class="va">this</span>.FIND(a)   <span class="co">// Find root of node a</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        root2 <span class="op">=</span> <span class="va">this</span>.FIND(b)   <span class="co">// Find root of node b</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> root1 <span class="op">!=</span> root2:     <span class="co">// Merge with weighted union</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">this</span>.weights[root2] <span class="op">&gt;</span> <span class="va">this</span>.weights[root1]:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                <span class="va">this</span>.array[root1] <span class="op">=</span> root2</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                <span class="va">this</span>.weights[root2] <span class="op">=</span> <span class="va">this</span>.weights[root2] <span class="op">+</span> <span class="va">this</span>.weights[root1]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                <span class="va">this</span>.array[root2] <span class="op">=</span> root1</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                <span class="va">this</span>.weights[root1] <span class="op">=</span> <span class="va">this</span>.weights[root1] <span class="op">+</span> <span class="va">this</span>.weights[root2]</span></code></pre></div>
<p>The following slideshow illustrates a series of UNION operations with
weighted union.</p>
<p>
<div id="UFCON" class="ssAV" data-short-name="UFCON" data-long-name="Union/Find Example" alt="Union/Find Example" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
</section>
<section id="path-compression" class="level3" data-number="5.12.4">
<h3 data-number="5.12.4"><span
class="header-section-number">5.12.4</span> Path Compression</h3>
<p>The weighted union rule helps to minimize the depth of the tree, but
we can do better than this. <a
href="5.12-the-unionfind-algorithm-optional.html#path-compression"
class="term"
title="When implementing the UNION/FIND algorithm, path compression is a local optimization step that can be performed during the FIND step. Once the root of the tree for the current object has been found, the path to the root can be traced a second time, with all objects in the tree made to point directly to the root. This reduces the depth of the tree from typically $\Theta(\log n)$ to nearly constant.">Path
compression</a> is a method that tends to create extremely shallow
trees. Path compression takes place while finding the root for a given
node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>.
Call this root
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>.
Path compression resets the parent of every node on the path from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
to point directly to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>.
This can be implemented by first finding
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>.
A second pass is then made along the path from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>,
assigning the parent field of each node encountered to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>.
Alternatively, a recursive algorithm can be implemented as follows. This
version of <code>FIND</code> not only returns the root of the current
node, but also makes all ancestors of the current node point to the
root.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ParentPointerTree:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return the root of current&#39;s tree with path compression</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    FIND(current):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">this</span>.array[current] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> current  <span class="co">// Base case: we are at the root</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            <span class="va">this</span>.array[current] <span class="op">=</span> <span class="va">this</span>.FIND(<span class="va">this</span>.array[current])</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">this</span>.array[current]</span></code></pre></div>
<p>The following slide show illustrates path compression using the last
step in the previous example.</p>
<p>
<div id="pathcompCON" class="ssAV" data-short-name="pathcompCON" data-long-name="Union/Find Path Compression Example" alt="Union/Find Path Compression Example" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<p>Path compression keeps the cost of each FIND operation very close to
constant.</p>
<p>To be more precise about what is meant by “very close to constant”,
the cost of path compression for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
FIND operations on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
nodes (when combined with the weighted union rule for joining sets) is
approximately
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><msup><mo>log</mo><mo>*</mo></msup><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n \log^* n)</annotation></semantics></math>.
The notation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>log</mo><mo>*</mo></msup><mi>n</mi></mrow><annotation encoding="application/x-tex">\log^* n</annotation></semantics></math>
means the number of times that the log of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
must be taken before
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \leq 1</annotation></semantics></math>.
For example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>log</mo><mo>*</mo></msup><mn>65536</mn></mrow><annotation encoding="application/x-tex">\log^* 65536</annotation></semantics></math>
is 4 because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mn>65536</mn><mo>=</mo><mn>16</mn><mo>,</mo><mo>log</mo><mn>16</mn><mo>=</mo><mn>4</mn><mo>,</mo><mo>log</mo><mn>4</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\log 65536 = 16, \log 16 = 4, \log 4 = 2</annotation></semantics></math>,
and finally
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mn>2</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\log 2 = 1</annotation></semantics></math>.
Thus,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>log</mo><mo>*</mo></msup><mi>n</mi></mrow><annotation encoding="application/x-tex">\log^* n</annotation></semantics></math>
grows <em>very</em> slowly, so the cost for a series of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
FIND operations is very close to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>.</p>
<p>Note that this does not mean that the tree resulting from processing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
equivalence pairs necessarily has depth
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mo>log</mo><mo>*</mo></msup><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(\log^* n)</annotation></semantics></math>.
One can devise a series of equivalence operations that yields
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(\log n)</annotation></semantics></math>
depth for the resulting tree. However, many of the equivalences in such
a series will look only at the roots of the trees being merged,
requiring little processing time. The <em>total</em> amount of
processing time required for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
operations will be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><msup><mo>log</mo><mo>*</mo></msup><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n \log^* n)</annotation></semantics></math>,
yielding nearly constant time for each equivalence operation. This is an
example of <a href="10-glossary.html#amortized-analysis" class="term"
title="Analysing the amortized complexity of an algorithm or problem.">amortized
analysis</a>.</p>
<p>The expression
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>log</mo><mo>*</mo></msup><mi>n</mi></mrow><annotation encoding="application/x-tex">\log^* n</annotation></semantics></math>
is closely related to the inverse of Ackermann’s function. For more
information about Ackermann’s function and the cost of path compression
for UNION/FIND, see [<a href="11-bibliography.html#tarjan75"
class="citation">Tarjan, 1975</a>]. The survey article by [<a
href="11-bibliography.html#galilitaliano91" class="citation">Galil &amp;
Italiano, 1991</a>] covers many aspects of the equivalence class
problem.</p>
<p>
<div id="UnionFindPRO" class="embedContainer">
<iframe id="UnionFindPRO_iframe" aria-label="UnionFindPRO" src="../interactive/General/UnionFindPRO.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>
</p>
</section>
</section>
</main>

<footer>
<nav class="sitenav">
<div class="navlink">
<a href="5.11-general-trees-optional.html" class="navbutton">&lt;&lt;</a>
<a href="5.11-general-trees-optional.html" accesskey="p" rel="previous">General Trees (optional)</a>
</div>
<div class="navlink">
<a href="5.13-sequential-tree-representations-optional.html" accesskey="n" rel="next">Sequential Tree Representations (optional)</a>
<a href="5.13-sequential-tree-representations-optional.html" class="navbutton">&gt;&gt;</a>
</div>
</nav>
</footer>

<script type="text/javascript" src="../interactive/General/UFfigCON.js"></script>
<script type="text/javascript" src="../interactive/General/UFconcomCON.js"></script>
<script type="text/javascript" src="../interactive/General/UFCON.js"></script>
<script type="text/javascript" src="../interactive/General/pathcompCON.js"></script>
</body>
</html>

