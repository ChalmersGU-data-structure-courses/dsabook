<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Cliff Shaffer" />
  <meta name="author" content="Peter Ljungl√∂f" />
  <meta name="author" content="Nick Smallbone" />
  <title>DSABook ‚Äì Solving Recurrence Relations (optional) (WORK IN
PROGRESS)</title>
  <style>
    div.sitenav { display: flex; flex-direction: row; flex-wrap: wrap; }
    span.navlink { flex: 1; }
    span.navlink-label { display: inline-block; min-width: 4em; }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="../bookstyle.css" />
  
  <link rel="stylesheet" href="../lib/JSAV.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaMOD.css" type="text/css" />
  <link rel="stylesheet" href="../lib/jquery.ui.min.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaStyle.css" type="text/css" />
  <link rel="stylesheet" href="../lib/ChalmersGU-interactive.css" type="text/css" />

  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
      },
      "HTML-CSS": {
        scale: "80",
      }
    });
  </script>

  <script type="text/javascript" src="../lib/jquery.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.migrate.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src="../lib/localforage.min.js"></script>
  <script type="text/javascript" src="../lib/accessibility.js"></script>
  <script type="text/javascript" src="../lib/jquery.ui.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.transit.js"></script>
  <script type="text/javascript" src="../lib/raphael.js"></script>
  <script type="text/javascript" src="../lib/JSAV.js"></script>
  <script type="text/javascript" src="../lib/config.js"></script>
  <script type="text/javascript" src="../lib/timeme.js"></script>
  <script type="text/javascript" src="../lib/odsaUtils.js"></script>
  <script type="text/javascript" src="../lib/odsaMOD.js"></script>
  <script type="text/javascript" src="../lib/d3.min.js"></script>
  <script type="text/javascript" src="../lib/d3-selection-multi.v1.min.js"></script>
  <script type="text/javascript" src="../lib/dataStructures.js"></script>
  <script type="text/javascript" src="../lib/conceptMap.js"></script>

  <script>
    ODSA.SETTINGS.MODULE_SECTIONS = [
    'internal-variables', 
    'getting-and-setting-values', 
    'adding-elements', 
    'add-practice-exericse', 
    'removing-elements', 
    'remove-practice-exericise', 
    'static-array-based-list-summary-questions', 
    'static-array-based-list:-full-code',
    ];
    ODSA.SETTINGS.MODULE_NAME = "DSABook";
    ODSA.SETTINGS.MODULE_LONG_NAME = "Data Structures and Algorithms";
    JSAV_OPTIONS['lang']='en';
    JSAV_EXERCISE_OPTIONS['code']='pseudo';
  </script>

<link href="../interactive/AlgAnal/ExpandRecurrenceCON.css" rel="stylesheet" type="text/css"/>
<link href="../interactive/AlgAnal/DandCRecurrenceCON.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav id="sitenav">
<div class="sitenav">
<span class="navlink">
<span class="navlink-label">Up:</span> <a href="3-algorithm-analysis.html" accesskey="u" rel="up">Algorithm Analysis</a>
</span>
<span class="navlink">
<span class="navlink-label">Top:</span> <a href="index.html" accesskey="t" rel="top">Data Structures and Algorithms</a>
</span>
</div>
<div class="sitenav">
<span class="navlink">
<span class="navlink-label">Next:</span> <a href="3.18-amortized-analysis-optional-work-in-progress.html" accesskey="n" rel="next">Amortized Analysis (optional) (WORK IN PROGRESS)</a>
</span>
<span class="navlink">
<span class="navlink-label">Previous:</span> <a href="3.16-summation-techniques-optional-work-in-progress.html" accesskey="p" rel="previous">Summation Techniques (optional) (WORK IN PROGRESS)</a>
</span>
</div>
</nav>
<section id="solving-recurrence-relations-optional-work-in-progress"
class="level2" data-number="3.17">
<h2 data-number="3.17"><span class="header-section-number">3.17</span>
Solving Recurrence Relations (optional) (WORK IN PROGRESS)</h2>
<div class="todo" type="Equation cross-reference">
<p>Throughout this module, there are references to equations, both on
this page and in the Summations module. These should be made into proper
cross-references rather than hard-coded equation numbers.</p>
</div>
<p>Recurrence relations are often used to model the cost of recursive
functions. For example, the standard <a
href="2.9-mergesort.html#mergesort">Mergesort</a> takes a list of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
splits it in half, performs Mergesort on each half, and finally merges
the two sublists in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
steps. The cost for this can be modeled as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>n</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray}
\mathbf{T}(n) &amp;=&amp; 2\mathbf{T}(n/2) + n
\end{eqnarray}
</annotation></semantics></math></p>
<p>In other words, the cost of the algorithm on input of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
is two times the cost for input of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math>
(due to the two recursive calls to Mergesort) plus
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
(the time to merge the sublists together again).</p>
<p>There are many approaches to solving recurrence relations, and we
briefly consider three here. The first is an estimation technique: Guess
the upper and lower bounds for the recurrence, use induction to prove
the bounds, and tighten as required. The second approach is to expand
the recurrence to convert it to a summation and then use summation
techniques. The third approach is to take advantage of already proven
theorems when the recurrence is of a suitable form. In particular,
typical divide-and-conquer algorithms such as Mergesort yield
recurrences of a form that fits a pattern for which we have a ready
solution.</p>
<section id="estimating-upper-and-lower-bounds" class="level3"
data-number="3.17.1">
<h3 data-number="3.17.1"><span
class="header-section-number">3.17.1</span> Estimating Upper and Lower
Bounds</h3>
<p>The first approach to solving recurrences is to guess the answer and
then attempt to prove it correct. If a correct upper or lower bound
estimate is given, an easy induction proof will verify this fact. If the
proof is successful, then try to tighten the bound. If the induction
proof fails, then loosen the bound and try again. Once the upper and
lower bounds match, you are finished. This is a useful technique when
you are only looking for asymptotic complexities. When seeking a precise
closed-form solution (i.e., you seek the constants for the expression),
this method will probably be too much work.</p>
<section id="example-20" class="level4 unnumbered topic">
<h4 class="unnumbered">Example</h4>
<p>Use the guessing technique to find the asymptotic bounds for
Mergesort, whose running time is described by the equation</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>2</mn><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>n</mi></mtd><mtd columnalign="center" style="text-align: center"><mo>;</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray}
\mathbf{T}(n) = 2\mathbf{T}(n/2) + n &amp;;&amp; \mathbf{T}(2) = 1
\end{eqnarray}
</annotation></semantics></math></p>
<p>We begin by guessing that this recurrence has an upper bound in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math>.
To be more precise, assume that</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>‚â§</mo></mtd><mtd columnalign="left" style="text-align: left"><msup><mi>n</mi><mn>2</mn></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray}
\mathbf{T}(n) &amp;\leq&amp; n^2
\end{eqnarray}
</annotation></semantics></math></p>
<p>We prove this guess is correct by induction. In this proof, we assume
that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
is a power of two, to make the calculations easy. For the base case,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn><mo>‚â§</mo><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbf{T}(2) = 1 \leq 2^2</annotation></semantics></math>.
For the induction step, we need to show that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚â§</mo><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) \leq n^2</annotation></semantics></math>
implies that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚â§</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbf{T}(2n) \leq (2n)^2</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mi>N</mi></msup><mo>,</mo><mi>N</mi><mo>‚â•</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n = 2^N, N \geq 1</annotation></semantics></math>.
The induction hypothesis is</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>‚â§</mo></mtd><mtd columnalign="left" style="text-align: left"><msup><mi>i</mi><mn>2</mn></msup><mo>,</mo><mspace width="0.222em"></mspace><mtext mathvariant="normal">for all</mtext><mspace width="0.222em"></mspace><mi>i</mi><mo>‚â§</mo><mi>n</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray}
\mathbf{T}(i) &amp;\leq&amp; i^2,\ \textrm{for all}\ i \leq n
\end{eqnarray}
</annotation></semantics></math></p>
<p>It follows that</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>2</mn><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><mi>n</mi><mo>‚â§</mo><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi><mo>‚â§</mo><mn>4</mn><msup><mi>n</mi><mn>2</mn></msup><mo>‚â§</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
\mathbf{T}(2n) = 2\mathbf{T}(n) + 2n \leq 2n^2 + 2n \leq 4n^2 \leq (2n)^2
</annotation></semantics></math></p>
<p>which is what we wanted to prove. Thus,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T}(n)</annotation></semantics></math>
is in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math>.</p>
<p>Is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math>
a good estimate? In the next-to-last step we went from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">n^2 + 2n</annotation></semantics></math>
to the much larger
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">4n^2</annotation></semantics></math>.
This suggests that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math>
is a high estimate. If we guess something smaller, such as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚â§</mo><mi>c</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) \leq cn</annotation></semantics></math>
for some constant
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>,
it should be clear that this cannot work because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mn>2</mn><mi>n</mi><mo>=</mo><mn>2</mn><mi>c</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">c 2 n = 2 c n</annotation></semantics></math>
and there is no room for the extra
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
cost to join the two pieces together. Thus, the true cost must be
somewhere between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">cn</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mn>2</mn></msup><annotation encoding="application/x-tex">n^2</annotation></semantics></math>.</p>
<p>Let us now try
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚â§</mo><mi>n</mi><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) \leq n \log n</annotation></semantics></math>.
For the base case, the definition of the recurrence sets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn><mo>‚â§</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>‚ãÖ</mo><mo>log</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\mathbf{T}(2) = 1 \leq (2 \cdot \log 2) = 2</annotation></semantics></math>.
Assume (induction hypothesis) that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚â§</mo><mi>n</mi><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) \leq n \log n</annotation></semantics></math>.
Then,</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>2</mn><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><mi>n</mi><mo>‚â§</mo><mn>2</mn><mi>n</mi><mo>log</mo><mi>n</mi><mo>+</mo><mn>2</mn><mi>n</mi><mo>‚â§</mo><mn>2</mn><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚â§</mo><mn>2</mn><mi>n</mi><mo>log</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">
\mathbf{T}(2n) = 2\mathbf{T}(n) + 2n \leq 2n \log n + 2n
\leq 2n(\log n + 1) \leq 2 n \log 2n
</annotation></semantics></math></p>
<p>which is what we seek to prove. In similar fashion, we can prove that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T}(n)</annotation></semantics></math>
is in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ©</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Omega(n \log n)</annotation></semantics></math>.
Thus,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T}(n)</annotation></semantics></math>
is also
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n \log n)</annotation></semantics></math>.</p>
</section>
<section id="example-21" class="level4 unnumbered topic">
<h4 class="unnumbered">Example</h4>
<p>We know that the factorial function grows exponentially. How does it
compare to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>?
To
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>n</mi></msup><annotation encoding="application/x-tex">n^n</annotation></semantics></math>?
Do they all grow ‚Äúequally fast‚Äù (in an asymptotic sense)? We can begin
by looking at a few initial terms.</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
</colgroup>
<thead>
<tr class="header">
<th
style="text-align: right;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math></th>
<th style="text-align: right;">1</th>
<th style="text-align: right;">2</th>
<th style="text-align: right;">3</th>
<th style="text-align: right;">4</th>
<th style="text-align: right;">5</th>
<th style="text-align: right;">6</th>
<th style="text-align: right;">7</th>
<th style="text-align: right;">8</th>
<th style="text-align: right;">9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: right;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">24</td>
<td style="text-align: right;">120</td>
<td style="text-align: right;">720</td>
<td style="text-align: right;">5040</td>
<td style="text-align: right;">40320</td>
<td style="text-align: right;">362880</td>
</tr>
<tr class="even">
<td
style="text-align: right;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math></td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">16</td>
<td style="text-align: right;">32</td>
<td style="text-align: right;">64</td>
<td style="text-align: right;">128</td>
<td style="text-align: right;">256</td>
<td style="text-align: right;">512</td>
</tr>
<tr class="odd">
<td
style="text-align: right;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>n</mi></msup><annotation encoding="application/x-tex">n^n</annotation></semantics></math></td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">256</td>
<td style="text-align: right;">3125</td>
<td style="text-align: right;">46656</td>
<td style="text-align: right;">823543</td>
<td style="text-align: right;">16777216</td>
<td style="text-align: right;">387420489</td>
</tr>
</tbody>
</table>
<p>We can also look at these functions in terms of their
recurrences.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mn>1</mn></mtd><mtd columnalign="left" style="text-align: left"><mi>n</mi><mo>=</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>!</mi></mtd><mtd columnalign="left" style="text-align: left"><mi>n</mi><mo>&gt;</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
n! = \left\{
\begin{array}{ll}
1 &amp; n=1\\
n(n-1)! &amp; n&gt;1\\
\end{array}
\right.
</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mn>2</mn></mtd><mtd columnalign="left" style="text-align: left"><mi>n</mi><mo>=</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>2</mn><mrow><mo stretchy="true" form="prefix">(</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mi>n</mi><mo>&gt;</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
2^n = \left\{
\begin{array}{ll}
2 &amp; n=1\\
2(2^{n-1}) &amp; n&gt;1\\
\end{array}
\right.
</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mi>n</mi></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mi>n</mi></mtd><mtd columnalign="left" style="text-align: left"><mi>n</mi><mo>=</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mi>n</mi><mo>&gt;</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
n^n = \left\{
\begin{array}{ll}
n &amp; n=1\\
n(n^{n-1}) &amp; n&gt;1\\
\end{array}
\right.
</annotation></semantics></math></p>
<p>At this point, our intuition should be telling us pretty clearly the
relative growth rates of these three functions. But how do we prove
formally which grows the fastest? And how do we decide if the
differences are significant in an asymptotic sense, or just constant
factor differences?</p>
<p>We can use logarithms to help us get an idea about the relative
growth rates of these functions. Clearly,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><msup><mn>2</mn><mi>n</mi></msup><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log 2^n = n</annotation></semantics></math>.
Equally clearly,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><msup><mi>n</mi><mi>n</mi></msup><mo>=</mo><mi>n</mi><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n^n = n \log n</annotation></semantics></math>.
We can easily see from this that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mi>n</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">o(n^n)</annotation></semantics></math>,
that is,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>n</mi></msup><annotation encoding="application/x-tex">n^n</annotation></semantics></math>
grows asymptotically faster than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>.</p>
<p>How does
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math>
fit into this? We can again take advantage of logarithms. Obviously
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi><mo>‚â§</mo><msup><mi>n</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">n! \leq n^n</annotation></semantics></math>,
so we know that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">\log n!</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math>.
But what about a lower bound for the factorial function? Consider the
following.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>n</mi><mi>!</mi></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>n</mi><mo>√ó</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>√ó</mo><mi>‚ãØ</mi><mo>√ó</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>√ó</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>√ó</mo><mi>‚ãØ</mi><mo>√ó</mo><mn>2</mn><mo>√ó</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>‚â•</mo></mtd><mtd columnalign="left" style="text-align: left"><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>√ó</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>√ó</mo><mi>‚ãØ</mi><mo>√ó</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>√ó</mo><mn>1</mn><mo>√ó</mo><mi>‚ãØ</mi><mo>√ó</mo><mn>1</mn><mo>√ó</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>n</mi><mi>/</mi><mn>2</mn></mrow></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray*}
n!  &amp; = &amp;  n \times (n - 1) \times \cdots \times \frac{n}{2} \times
(\frac{n}{2} - 1) \times \cdots \times 2 \times 1\\
 &amp; \geq &amp;  \frac{n}{2} \times \frac{n}{2} \times \cdots \times \frac{n}{2}
\times 1 \times \cdots \times 1 \times 1\\
 &amp; = &amp;  (\frac{n}{2})^{n/2}
\end{eqnarray*}
</annotation></semantics></math></p>
<p>Therefore</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi><mi>!</mi><mo>‚â•</mo><mo>log</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>n</mi><mi>/</mi><mn>2</mn></mrow></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\log n! \geq \log(\frac{n}{2})^{n/2} =
(\frac{n}{2})\log(\frac{n}{2})
</annotation></semantics></math></p>
<p>In other words,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">\log n!</annotation></semantics></math>
is in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ©</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Omega(n \log n)</annotation></semantics></math>.
Thus,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi><mi>!</mi><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\log n! = \Theta(n \log n)</annotation></semantics></math>.</p>
<p>Note that this does <strong>not</strong> mean that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mi>n</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">n! = \Theta(n^n)</annotation></semantics></math>.
Because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><msup><mi>n</mi><mn>2</mn></msup><mo>=</mo><mn>2</mn><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n^2 = 2 \log n</annotation></semantics></math>,
it follows that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\log n = \Theta(\log n^2)</annotation></semantics></math>
but
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>‚â†</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">n \neq \Theta(n^2)</annotation></semantics></math>.
The log function often works as a ‚Äúflattener‚Äù when dealing with
asymptotics. That is, whenever
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\log f(n)</annotation></semantics></math>
is in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(\log g(n))</annotation></semantics></math>
we know that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math>
is in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(g(n))</annotation></semantics></math>.
But knowing that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\log f(n) = \Theta(\log g(n))</annotation></semantics></math>
does not necessarily mean that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n) = \Theta(g(n))</annotation></semantics></math>.</p>
</section>
<section id="example-22" class="level4 unnumbered topic">
<h4 class="unnumbered">Example</h4>
<p>What is the growth rate of the Fibonacci sequence? We define the
Fibonacci sequence as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n) = f(n-1) + f(n-2)</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>‚â•</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n \geq 2</annotation></semantics></math>;
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(0) = f(1) = 1</annotation></semantics></math>.</p>
<p>In this case it is useful to compare the ratio of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n-1)</annotation></semantics></math>.
The following table shows the first few values.</p>
<table>
<thead>
<tr class="header">
<th
style="text-align: right;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math></th>
<th style="text-align: right;">1</th>
<th style="text-align: right;">2</th>
<th style="text-align: right;">3</th>
<th style="text-align: right;">4</th>
<th style="text-align: right;">5</th>
<th style="text-align: right;">6</th>
<th style="text-align: right;">7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: right;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">13</td>
<td style="text-align: right;">21</td>
</tr>
<tr class="even">
<td
style="text-align: right;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n)/f(n-1)</annotation></semantics></math></td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: right;">1.666</td>
<td style="text-align: right;">1.625</td>
<td style="text-align: right;">1.615</td>
<td style="text-align: right;">1.619</td>
</tr>
</tbody>
</table>
<p>If we continue for more terms, the ratio appears to converge on a
value slightly greater then 1.618. Assuming
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n)/f(n-1)</annotation></semantics></math>
really does converge to a fixed value as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
grows, we can determine what that value must be.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>‚Üí</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">
\frac{f(n)}{f(n-2)} = \frac{f(n-1)}{f(n-2)} + \frac{f(n-2)}{f(n-2)}
\rightarrow x+1
</annotation></semantics></math></p>
<p>for some value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>.
This follows from the fact that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n) = f(n-1) + f(n-2)</annotation></semantics></math>.
We divide by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n-2)</annotation></semantics></math>
to make the second term go away, and we also get something useful in the
first term. Remember that the goal of such manipulations is to give us
an equation that relates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math>
to something without recursive calls.</p>
<p>For large
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
we also observe that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mfrac><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>‚Üí</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
\frac{f(n)}{f(n-2)} = \frac{f(n)}{f(n-1)}\frac{f(n-1)}{f(n-2)}
\rightarrow x^2
</annotation></semantics></math></p>
<p>as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
gets big. This comes from multiplying
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n)/f(n-2)</annotation></semantics></math>
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n-1)/f(n-1)</annotation></semantics></math>
and rearranging.</p>
<p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
exists, then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>‚àí</mo><mi>x</mi><mo>‚àí</mo><mn>1</mn><mo>‚Üí</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x^2 - x - 1 \rightarrow 0</annotation></semantics></math>.
Using the quadratic equation, the only solution greater than one is</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><msqrt><mn>5</mn></msqrt></mrow><mn>2</mn></mfrac><mo>‚âà</mo><mn>1.618</mn></mrow><annotation encoding="application/x-tex">
x = \frac{1 + \sqrt{5}}{2} \approx 1.618
</annotation></semantics></math></p>
<p>This expression also has the name
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>œï</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math>.
What does this say about the growth rate of the Fibonacci sequence? It
is exponential, with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>œï</mi><mi>n</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n) = \Theta(\phi^n)</annotation></semantics></math>.
More precisely,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math>
converges to</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><msup><mi>œï</mi><mi>n</mi></msup><mo>‚àí</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>œï</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup></mrow><msqrt><mn>5</mn></msqrt></mfrac><annotation encoding="application/x-tex">
\frac{\phi^n - (1 - \phi)^n}{\sqrt{5}}
</annotation></semantics></math></p>
</section>
</section>
<section id="expanding-recurrences" class="level3" data-number="3.17.2">
<h3 data-number="3.17.2"><span
class="header-section-number">3.17.2</span> Expanding Recurrences</h3>
<p>Estimating bounds is effective if you only need an approximation to
the answer. More precise techniques are required to find an exact
solution. One approach is called <a href="10-glossary.html#expanding-the-recurrence" class="term">expanding the
recurrence</a>. In this method, the smaller terms on the right side
of the equation are in turn replaced by their definition. This is the
expanding step. These terms are again expanded, and so on, until a full
series with no recurrence results. This yields a <a href="10-glossary.html#summation" class="term">summation</a>, and techniques for solving summations can
then be used.</p>
<p>
<div id="ExpandRecurrenceCON" class="ssAV" data-short-name="ExpandRecurrenceCON" data-long-name="Divide-and-Conquer Expansion Slideshow" alt="Divide-and-Conquer Expansion Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<section id="example-23" class="level4 unnumbered topic">
<h4 class="unnumbered">Example</h4>
<p>Our next example models the cost of the algorithm to build a heap.
You should recall that to build a <a
href="7.2-heaps-and-priority-queues.html#heaps-and-priority-queues">heap</a>,
we first heapify the two subheaps, then push down the root to its proper
position. The cost is:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚â§</mo><mn>2</mn><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">
f(n) \leq 2f(n/2) + 2 \log n
</annotation></semantics></math></p>
<p>Let us find a closed form solution for this recurrence. We can expand
the recurrence a few times to see that</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>‚â§</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><mo>log</mo><mi>n</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>‚â§</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mrow><mo stretchy="true" form="prefix">[</mo><mn>2</mn><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mn>4</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><mo>log</mo><mi>n</mi><mi>/</mi><mn>2</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>+</mo><mn>2</mn><mo>log</mo><mi>n</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>‚â§</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mrow><mo stretchy="true" form="prefix">[</mo><mn>2</mn><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mn>8</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><mo>log</mo><mi>n</mi><mi>/</mi><mn>4</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><mo>log</mo><mi>n</mi><mi>/</mi><mn>2</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>+</mo><mn>2</mn><mo>log</mo><mi>n</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray*}
f(n) &amp; \leq &amp;  2f(n/2) + 2 \log n \\
     &amp; \leq &amp;  2[2f(n/4) + 2 \log n/2] + 2 \log n \\
     &amp; \leq &amp;  2[2(2f(n/8) + 2 \log n/4) + 2 \log n/2] + 2 \log n
\end{eqnarray*}
</annotation></semantics></math></p>
<p>We can deduce from this expansion that this recurrence is equivalent
to following summation and its derivation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>‚â§</mo></mtd><mtd columnalign="left" style="text-align: left"><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mo>log</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></munderover><msup><mn>2</mn><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><msup><mn>2</mn><mi>i</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mo>log</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></munderover><msup><mn>2</mn><mi>i</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo>‚àí</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mo>log</mo><mi>n</mi><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mo>log</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></munderover><msup><mn>2</mn><mi>i</mi></msup><mo>‚àí</mo><mn>4</mn><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mo>log</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></munderover><mi>i</mi><msup><mn>2</mn><mrow><mi>i</mi><mo>‚àí</mo><mn>1</mn></mrow></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mi>n</mi><mo>log</mo><mi>n</mi><mo>‚àí</mo><mn>2</mn><mo>log</mo><mi>n</mi><mo>‚àí</mo><mn>2</mn><mi>n</mi><mo>log</mo><mi>n</mi><mo>+</mo><mn>4</mn><mi>n</mi><mo>‚àí</mo><mn>4</mn></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>4</mn><mi>n</mi><mo>‚àí</mo><mn>2</mn><mo>log</mo><mi>n</mi><mo>‚àí</mo><mn>4</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray*}
f(n)  &amp; \leq &amp;  \sum_{i=0}^{\log n -1} 2^{i+1} \log(n/2^i) \\
      &amp;  =   &amp;  2 \sum_{i=0}^{\log n -1} 2^i (\log n - i) \\
      &amp;  =   &amp;  2 \log n \sum_{i=0}^{\log n -1} 2^i - 4 \sum_{i=0}^{\log n -1} i 2^{i-1} \\
      &amp;  =   &amp;  2 n \log n - 2 \log n - 2 n \log n + 4n -4 \\
      &amp;  =   &amp;  4n - 2 \log n - 4
\end{eqnarray*}
</annotation></semantics></math></p>
</section>
</section>
<section id="divide-and-conquer-recurrences" class="level3"
data-number="3.17.3">
<h3 data-number="3.17.3"><span
class="header-section-number">3.17.3</span> Divide-and-Conquer
Recurrences</h3>
<p>The third approach to solving recurrences is to take advantage of
known theorems that provide the solution for classes of recurrences. Of
particular practical use is a theorem that gives the answer for a class
known as <a href="10-glossary.html#divide-and-conquer-recurrences" class="term">divide-and-conquer recurrences</a>. These
have the form</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>a</mi><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>c</mi><msup><mi>n</mi><mi>k</mi></msup></mtd><mtd columnalign="center" style="text-align: center"><mo>;</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>c</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray}
\mathbf{T}(n) = a\mathbf{T}(n/b) + cn^k &amp;;&amp; \mathbf{T}(1) = c
\end{eqnarray}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
are constants. In general, this recurrence describes a problem of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
divided into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>
subproblems of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>/</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">n/b</annotation></semantics></math>,
while
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msup><mi>n</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">cn^k</annotation></semantics></math>
is the amount of work necessary to combine the partial solutions.
Mergesort is an example of a divide and conquer algorithm, and its
recurrence fits this form. So does binary search. We use the method of
expanding recurrences to derive the general solution for any divide and
conquer recurrence, assuming that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mi>b</mi><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">n = b^m</annotation></semantics></math>.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>a</mi><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>c</mi><msup><mi>n</mi><mi>k</mi></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><msup><mi>b</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>c</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>c</mi><msup><mi>n</mi><mi>k</mi></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>a</mi><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><msup><mi>b</mi><mn>3</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>c</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><msup><mi>b</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi></msup><mo stretchy="true" form="postfix">]</mo></mrow><mo>+</mo><mi>c</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>c</mi><msup><mi>n</mi><mi>k</mi></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msup><mi>a</mi><mi>m</mi></msup><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msup><mi>a</mi><mrow><mi>m</mi><mo>‚àí</mo><mn>1</mn></mrow></msup><mi>c</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><msup><mi>b</mi><mrow><mi>m</mi><mo>‚àí</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi></msup><mo>+</mo><mi>‚ãØ</mi><mo>+</mo><mi>a</mi><mi>c</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi></msup><mo>+</mo><mi>c</mi><msup><mi>n</mi><mi>k</mi></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msup><mi>a</mi><mi>m</mi></msup><mi>c</mi><mo>+</mo><msup><mi>a</mi><mrow><mi>m</mi><mo>‚àí</mo><mn>1</mn></mrow></msup><mi>c</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><msup><mi>b</mi><mrow><mi>m</mi><mo>‚àí</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi></msup><mo>+</mo><mi>‚ãØ</mi><mo>+</mo><mi>a</mi><mi>c</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>k</mi></msup><mo>+</mo><mi>c</mi><msup><mi>n</mi><mi>k</mi></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>c</mi><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><msup><mi>a</mi><mrow><mi>m</mi><mo>‚àí</mo><mi>i</mi></mrow></msup><msup><mi>b</mi><mrow><mi>i</mi><mi>k</mi></mrow></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>c</mi><msup><mi>a</mi><mi>m</mi></msup><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>b</mi><mi>k</mi></msup><mi>/</mi><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>i</mi></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray*}
\mathbf{T}(n)  &amp;  =  &amp;  a\mathbf{T}(n/b) + cn^k \\
            &amp;  =  &amp;  a(a\mathbf{T}(n/b^2) + c(n/b)^k) + cn^k \\
            &amp;  =  &amp;  a(a[a\mathbf{T}(n/b^3) + c(n/b^2)^k] + c(n/b)^k) + cn^k \\
            &amp;  =  &amp;  a^m\mathbf{T}(1) + a^{m-1}c(n/b^{m-1})^k + \cdots + ac(n/b)^k + cn^k \\
            &amp;  =  &amp;  a^mc + a^{m-1}c(n/b^{m-1})^k + \cdots + ac(n/b)^k + cn^k \\
            &amp;  =  &amp;  c\sum_{i=0}^{m} a^{m-i} b^{ik} \\
            &amp;  =  &amp; ca^m\sum_{i=0}^{m} (b^k/a)^i
\end{eqnarray*}
</annotation></semantics></math></p>
<p>Here is a more visual presentation of this same derivation.</p>
<p>
<div id="DandCRecurrenceCON" class="ssAV" data-short-name="DandCRecurrenceCON" data-long-name="Divide-and-Conquer Expansion Slideshow2" alt="Divide-and-Conquer Expansion Slideshow2" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<p>So, we are left with this result:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>c</mi><msup><mi>a</mi><mi>m</mi></msup><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>b</mi><mi>k</mi></msup><mi>/</mi><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">
\mathbf{T}(n) = ca^m\sum_{i=0}^{m} (b^k/a)^i
</annotation></semantics></math></p>
<p>At this point, it is useful to note that</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msup><mi>a</mi><mi>m</mi></msup><mo>=</mo><msup><mi>a</mi><mrow><msub><mo>log</mo><mi>b</mi></msub><mi>n</mi></mrow></msup><mo>=</mo><msup><mi>n</mi><mrow><msub><mo>log</mo><mi>b</mi></msub><mi>a</mi></mrow></msup><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray}
\label{ThmEquiv}
a^m = a^{\log_bn} = n^{\log_ba}.
\end{eqnarray}
</annotation></semantics></math></p>
<p>This gives us</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>c</mi><msup><mi>n</mi><mrow><msub><mo>log</mo><mi>b</mi></msub><mi>a</mi></mrow></msup><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>b</mi><mi>k</mi></msup><mi>/</mi><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">
\mathbf{T}(n) = c n^{\log_ba} \sum_{i=0}^{m} (b^k/a)^i
</annotation></semantics></math></p>
<p>The summation part of this equation is a geometric series whose sum
depends on the ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><msup><mi>b</mi><mi>k</mi></msup><mi>/</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">r = b^k/a</annotation></semantics></math>.
There are three cases.</p>
<ol type="1">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r&lt;1</annotation></semantics></math>.
From Equation (4) of Module <a href="10-glossary.html#summation" class="term">summation</a>,</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><msup><mi>r</mi><mi>i</mi></msup><mo>&lt;</mo><mn>1</mn><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>‚àí</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.222em"></mspace><mtext mathvariant="normal">a constant</mtext></mrow><annotation encoding="application/x-tex">
\sum_{i=0}^{m} r^i &lt; 1/(1-r),\ \textrm{a constant}
</annotation></semantics></math></p>
<p>Thus,</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>a</mi><mi>m</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>b</mi></msub><mi>a</mi></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathbf{T}(n) = \Theta(a^m) = \Theta(n^{log_ba})
</annotation></semantics></math></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r=1</annotation></semantics></math>.
Because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><msup><mi>b</mi><mi>k</mi></msup><mi>/</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">r = b^k/a</annotation></semantics></math>,
we know that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><msup><mi>b</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">a = b^k</annotation></semantics></math>.
From the definition of logarithms it follows immediately that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><msub><mo>log</mo><mi>b</mi></msub><mi>a</mi></mrow><annotation encoding="application/x-tex">k = \log_b a</annotation></semantics></math>.
Also note that since we defined
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mi>b</mi><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">n = b^m</annotation></semantics></math>,
then
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><msub><mo>log</mo><mi>b</mi></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">m = \log_b n</annotation></semantics></math>.
Thus,</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><msup><mi>r</mi><mi>i</mi></msup><mo>=</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo>=</mo><msub><mo>log</mo><mi>b</mi></msub><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">
\sum_{i=0}^{m} r^i = m + 1 = \log_bn + 1
</annotation></semantics></math></p>
<p>Because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>m</mi></msup><mo>=</mo><msup><mi>n</mi><mrow><msub><mo>log</mo><mi>b</mi></msub><mi>a</mi></mrow></msup><mo>=</mo><msup><mi>n</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">a^m = n^{\log_b a} = n^k</annotation></semantics></math>,
we have</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mrow><msub><mo>log</mo><mi>b</mi></msub><mi>a</mi></mrow></msup><msub><mo>log</mo><mi>b</mi></msub><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mi>k</mi></msup><msub><mo>log</mo><mi>b</mi></msub><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathbf{T}(n) = \Theta(n^{\log_ba}\log_b n) = \Theta(n^k\log_b n)
</annotation></semantics></math></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r&gt;1</annotation></semantics></math>.
From Equation (5) of Module <a href="10-glossary.html#summation" class="term">summation</a>,</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>‚àë</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><msup><mi>r</mi><mi>i</mi></msup><mo>=</mo><mfrac><mrow><msup><mi>r</mi><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>‚àí</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>‚àí</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>r</mi><mi>m</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\sum_{i=0}^{m} r^i = \frac{r^{m+1} - 1}{r - 1} = \Theta(r^m)
</annotation></semantics></math></p>
<p>Thus,</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>a</mi><mi>m</mi></msup><msup><mi>r</mi><mi>m</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>a</mi><mi>m</mi></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>b</mi><mi>k</mi></msup><mi>/</mi><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>m</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>b</mi><mrow><mi>k</mi><mi>m</mi></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mi>k</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathbf{T}(n) = \Theta(a^mr^m)
           = \Theta(a^m(b^k/a)^m)
           = \Theta(b^{km})
           = \Theta(n^k)
</annotation></semantics></math></p></li>
</ol>
<p>We can summarize the above derivation as the following theorem,
sometimes referred to as the <a href="10-glossary.html#master-theorem" class="term">Master
Theorem</a>.</p>
<div id="RecurThm">
<section id="theorem" class="level4 unnumbered topic">
<h4 class="unnumbered">Theorem</h4>
<p><strong>The Master Theorem:</strong> For any recurrence relation of
the form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>a</mi><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>c</mi><msup><mi>n</mi><mi>k</mi></msup><mo>,</mo><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = a\mathbf{T}(n/b) + cn^k, \mathbf{T}(1) = c</annotation></semantics></math>,
the following relationships hold.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mrow><msub><mo>log</mo><mi>b</mi></msub><mi>a</mi></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mrow><mi>a</mi><mo>&gt;</mo><msup><mi>b</mi><mi>k</mi></msup></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mi>k</mi></msup><msub><mo>log</mo><mi>b</mi></msub><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mrow><mi>a</mi><mo>=</mo><msup><mi>b</mi><mi>k</mi></msup></mrow></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mi>k</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mrow><mi>a</mi><mo>&lt;</mo><msup><mi>b</mi><mi>k</mi></msup></mrow><mtext mathvariant="normal">.</mtext></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\mathbf{T}(n) = \left\{ \begin{array}{ll}
             \Theta(n^{\log_ba})  &amp;  \mbox{if \(a &gt; b^k\)} \\
             \Theta(n^k\log_b n)    &amp;  \mbox{if \(a = b^k\)} \\
             \Theta(n^k)          &amp;  \mbox{if \(a &lt; b^k\).}
            \end{array}
   \right.
</annotation></semantics></math></p>
</section>
</div>
<p>This theorem may be applied whenever appropriate, rather than
re-deriving the solution for the recurrence.</p>
<section id="example-24" class="level4 unnumbered topic">
<h4 class="unnumbered">Example</h4>
<p>Apply the Master Theorem to solve</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>3</mn><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mn>5</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>8</mn><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
\mathbf{T}(n) = 3\mathbf{T}(n/5) + 8n^2
</annotation></semantics></math></p>
<p>Because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">a=3</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">b=5</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">c=8</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math>,
we find that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>&lt;</mo><msup><mn>5</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">3&lt;5^2</annotation></semantics></math>.
Applying case (3) of the theorem,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = \Theta(n^2)</annotation></semantics></math>.</p>
</section>
<section id="example-25" class="level4 unnumbered topic">
<h4 class="unnumbered">Example</h4>
<p>Use the Master Theorem to solve the recurrence relation for
Mergesort:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>2</mn><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>/</mi><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>n</mi></mtd><mtd columnalign="center" style="text-align: center"><mo>;</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray}
\mathbf{T}(n) = 2\mathbf{T}(n/2) + n &amp;;&amp; \mathbf{T}(1) = 1
\end{eqnarray}
</annotation></semantics></math></p>
<p>Because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a=2</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">b=2</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c=1</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math>,
we find that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>=</mo><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2 = 2^1</annotation></semantics></math>.
Applying case (2) of the theorem,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = \Theta(n \log n)</annotation></semantics></math>.</p>
</section>
</section>
<section id="average-case-analysis-of-quicksort" class="level3"
data-number="3.17.4">
<h3 data-number="3.17.4"><span
class="header-section-number">3.17.4</span> Average-Case Analysis of
Quicksort</h3>
<p>In Module <a href="2.11-quicksort.html#quicksort">Quicksort</a>, we
determined that the average-case analysis of Quicksort had the following
recurrence:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>c</mi><mi>n</mi><mo>+</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>‚àë</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy="true" form="prefix">[</mo><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo>‚àí</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>;</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>c</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray}
\mathbf{T}(n) = cn + \frac{1}{n}\sum_{k=0}^{n-1} [\mathbf{T}(k) + \mathbf{T}(n -1 - k)]
&amp;;&amp; \mathbf{T}(0) = \mathbf{T}(1) = c
\end{eqnarray}
</annotation></semantics></math></p>
<p>The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">cn</annotation></semantics></math>
term is an upper bound on the <span class="title-ref">findpivot</span>
and <span class="title-ref">partition</span> steps. This equation comes
from assuming that the partitioning element is equally likely to occur
in any position
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>.
It can be simplified by observing that the two recurrence terms
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T}(k)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo>‚àí</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T}(n - 1 - k)</annotation></semantics></math>
are equivalent, because one simply counts up from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">T(0)</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">T(n-1)</annotation></semantics></math>
while the other counts down from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">T(n-1)</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">T(0)</annotation></semantics></math>.
This yields</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>c</mi><mi>n</mi><mo>+</mo><mfrac><mn>2</mn><mi>n</mi></mfrac><munderover><mo>‚àë</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></munderover><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray}
\mathbf{T}(n) &amp;=&amp; cn + \frac{2}{n}\sum_{k=0}^{n-1} \mathbf{T}(k)
\end{eqnarray}
</annotation></semantics></math></p>
<p>This form is known as a <a href="10-glossary.html#recurrence-with-full-history" class="term">recurrence with full
history</a>. The key to solving such a recurrence is to cancel out
the summation terms. The shifting method for summations provides a way
to do this. Multiply both sides by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
and subtract the result from the formula for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">n\mathbf{T}(n+1)</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>n</mi><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>c</mi><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><munderover><mo>‚àë</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></munderover><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>c</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mn>2</mn><munderover><mo>‚àë</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray*}
n\mathbf{T}(n)  &amp;  =  &amp;  cn^2 + 2 \sum_{k=1}^{n-1} \mathbf{T}(k)\\
(n+1)\mathbf{T}(n+1)  &amp;  =  &amp;  c(n+1)^2 + 2 \sum_{k=1}^{n} \mathbf{T}(k)
\end{eqnarray*}
</annotation></semantics></math></p>
<p>Subtracting
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">n\mathbf{T}(n)</annotation></semantics></math>
from both sides yields:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àí</mo><mi>n</mi><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>c</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>‚àí</mo><mi>c</mi><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àí</mo><mi>n</mi><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mfrac><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray*}
(n+1)\mathbf{T}(n+1) - n\mathbf{T}(n)  &amp;  =  &amp;  c(n+1)^2 - cn^2 + 2\mathbf{T}(n)\\
(n+1)\mathbf{T}(n+1) - n\mathbf{T}(n)  &amp;  =  &amp;  c(2n+1) + 2\mathbf{T}(n)\\
(n+1)\mathbf{T}(n+1)  &amp;  =  &amp;  c(2n+1) + (n+2)\mathbf{T}(n)\\
\mathbf{T}(n+1)  &amp;  =  &amp;  \frac{c(2n+1)}{n+1} + \frac{n+2}{n+1}\mathbf{T}(n)
\end{eqnarray*}
</annotation></semantics></math></p>
<p>At this point, we have eliminated the summation and can now use our
normal methods for solving recurrences to get a closed-form solution.
Note that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>&lt;</mo><mn>2</mn><mi>c</mi></mrow><annotation encoding="application/x-tex">\frac{c(2n+1)}{n+1} &lt; 2c</annotation></semantics></math>,
so we can simplify the result. Expanding the recurrence, we get</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>‚â§</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mi>c</mi><mo>+</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mi>c</mi><mo>+</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>c</mi><mo>+</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mi>c</mi><mo>+</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>c</mi><mo>+</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>c</mi><mo>+</mo><mfrac><mi>n</mi><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></mfrac><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>‚àí</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mi>c</mi><mo>+</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>c</mi><mo>+</mo><mi>‚ãØ</mi><mo>+</mo><mfrac><mn>4</mn><mn>3</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mi>c</mi><mo>+</mo><mfrac><mn>3</mn><mn>2</mn></mfrac><mi>ùêì</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mo>+</mo><mi>‚ãØ</mi><mo>+</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mi>‚ãØ</mi><mfrac><mn>3</mn><mn>2</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>+</mo><mi>‚ãØ</mi><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><mi>c</mi><mo>+</mo><mn>2</mn><mi>c</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>‚Ñã</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>‚àí</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray*}
\mathbf{T}(n+1)  &amp;  \leq  &amp;  2c + \frac{n+2}{n+1} \mathbf{T}(n)\\
           &amp;  =  &amp;  2c + \frac{n+2}{n+1}\left (2c +
                     \frac{n+1}{n}\mathbf{T}(n-1)\right )\\
           &amp;  =  &amp;  2c + \frac{n+2}{n+1}\left (2c + \frac{n+1}{n}\left
                    (2c + \frac{n}{n-1}\mathbf{T}(n-2)\right )\right )\\
           &amp;  =  &amp;  2c + \frac{n+2}{n+1}\left (2c + \cdots +
                         \frac{4}{3}(2c + \frac{3}{2}\mathbf{T}(1))\right )\\
           &amp;  =  &amp;  2c\left (1 + \frac{n+2}{n+1}
                  + \frac{n+2}{n+1}\frac{n+1}{n} + \cdots
                  + \frac{n+2}{n+1}\frac{n+1}{n}\cdots\frac{3}{2}\right )\\
           &amp;  =  &amp;  2c\left (1 + (n+2)\left (\frac{1}{n+1}
                  + \frac{1}{n} + \cdots + \frac{1}{2}\right )\right )\\
           &amp;  =  &amp;  2c + 2c(n+2)\left (\mathcal{H}_{n+1} - 1\right )
\end{eqnarray*}
</annotation></semantics></math></p>
<p>for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>‚Ñã</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">\mathcal{H}_{n+1}</annotation></semantics></math>,
the Harmonic Series. From Equation (10) of Module <a href="10-glossary.html#summation" class="term">summation</a>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>‚Ñã</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{H}_{n+1} = \Theta(\log n)</annotation></semantics></math>,
so the final solution is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œò</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n \log n)</annotation></semantics></math>.</p>
</section>
</section>
<script type="text/javascript" src="../interactive/AlgAnal/ExpandRecurrenceCON.js"></script>
<script type="text/javascript" src="../interactive/AlgAnal/DandCRecurrenceCON.js"></script>
</body>
</html>
