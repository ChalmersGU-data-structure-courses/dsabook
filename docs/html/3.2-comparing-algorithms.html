<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Cliff Shaffer" />
  <meta name="author" content="Peter Ljunglöf" />
  <meta name="author" content="Nick Smallbone" />
  <title>DSABook – Comparing Algorithms</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #204a87; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #204a87; font-weight: bold; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../css/main.css" />
  <link rel="stylesheet" href="../css/book.css" />
  <link rel="stylesheet" href="../css/quiz.css" />
  <link rel="stylesheet" href="../css/mobile.css" />
  
  <link rel="stylesheet" href="../lib/JSAV.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaMOD.css" type="text/css" />
  <link rel="stylesheet" href="../lib/jquery.ui.min.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaStyle.css" type="text/css" />
  <link rel="stylesheet" href="../lib/ChalmersGU-interactive.css" type="text/css" />

  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
      },
      "HTML-CSS": {
        scale: "80",
      }
    });
  </script>

  <script type="text/javascript" src="../lib/jquery.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.migrate.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src="../lib/localforage.min.js"></script>
  <script type="text/javascript" src="../lib/accessibility.js"></script>
  <script type="text/javascript" src="../lib/jquery.ui.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.transit.js"></script>
  <script type="text/javascript" src="../lib/raphael.js"></script>
  <script type="text/javascript" src="../lib/JSAV.js"></script>
  <script type="text/javascript" src="../lib/config.js"></script>
  <script type="text/javascript" src="../lib/timeme.js"></script>
  <script type="text/javascript" src="../lib/odsaUtils.js"></script>
  <script type="text/javascript" src="../lib/odsaMOD.js"></script>
  <script type="text/javascript" src="../lib/d3.min.js"></script>
  <script type="text/javascript" src="../lib/d3-selection-multi.v1.min.js"></script>
  <script type="text/javascript" src="../lib/dataStructures.js"></script>
  <script type="text/javascript" src="../lib/conceptMap.js"></script>

  <script>
    ODSA.SETTINGS.MODULE_SECTIONS = [
    'internal-variables', 
    'getting-and-setting-values', 
    'adding-elements', 
    'add-practice-exericse', 
    'removing-elements', 
    'remove-practice-exericise', 
    'static-array-based-list-summary-questions', 
    'static-array-based-list:-full-code',
    ];
    ODSA.SETTINGS.MODULE_NAME = "DSABook";
    ODSA.SETTINGS.MODULE_LONG_NAME = "Data Structures and Algorithms";
    JSAV_OPTIONS['lang']='en';
    JSAV_EXERCISE_OPTIONS['code']='pseudo';
  </script>

  
  <script type="text/javascript" src="../scripts/quizhandler.js"></script>
<link href="../interactive/AlgAnal/GrowthRatesCON.css" rel="stylesheet" type="text/css"/>
<link href="../interactive/AlgAnal/GrowthRatesZoomCON.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav id="sitenav">
<div class="sitenav">
<span class="navlink">
<span class="navlink-label">Up:</span> <a href="3-algorithm-analysis.html" accesskey="u" rel="up">Algorithm Analysis</a>
</span>
<span class="navlink">
<span class="navlink-label">Top:</span> <a href="index.html" accesskey="t" rel="top">Data Structures and Algorithms</a>
</span>
</div>
<div class="sitenav">
<span class="navlink">
<span class="navlink-label">Previous:</span> <a href="3.1-problems-algorithms-and-programs.html" accesskey="p" rel="previous">Problems, Algorithms, and Programs</a>
</span>
<span class="navlink">
<span class="navlink-label">Next:</span> <a href="3.3-best-worst-and-average-cases.html" accesskey="n" rel="next">Best, Worst, and Average Cases</a>
</span>
</div>
</nav>
<section id="comparing-algorithms" class="level2" data-number="3.2">
<h2 data-number="3.2"><span class="header-section-number">3.2</span>
Comparing Algorithms</h2>
<section id="introduction-1" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1"><span class="header-section-number">3.2.1</span>
Introduction</h3>
<p>How do you compare two algorithms for solving some problem in terms
of efficiency? We could implement both algorithms as computer programs
and then run them on a suitable range of inputs, measuring how much of
the resources in question each program uses. This approach is often
unsatisfactory for four reasons. First, there is the effort involved in
programming and testing two algorithms when at best you want to keep
only one. Second, when empirically comparing two algorithms there is
always the chance that one of the programs was “better written” than the
other, and therefore the relative qualities of the underlying algorithms
are not truly represented by their implementations. This can easily
occur when the programmer has a bias regarding the algorithms. Third,
the choice of empirical test cases might unfairly favor one algorithm.
Fourth, you could find that even the better of the two algorithms does
not fall within your resource budget. In that case you must begin the
entire process again with yet another program implementing a new
algorithm. But, how would you know if any algorithm can meet the
resource budget? Perhaps the problem is simply too difficult for any
implementation to be within budget.</p>
<p>These problems can often be avoided by using asymptotic analysis.
Asymptotic analysis measures the efficiency of an algorithm, or its
implementation as a program, as the input size becomes large. It is
actually an estimating technique and does not tell us anything about the
relative merits of two programs where one is always “slightly faster”
than the other. However, asymptotic analysis has proved useful to
computer scientists who must determine if a particular algorithm is
worth considering for implementation.</p>
<p>The critical resource for a program is most often its running time.
However, you cannot pay attention to running time alone. You must also
be concerned with other factors such as the space required to run the
program (both main memory and disk space). Typically you will analyze
the <em>time</em> required for an <em>algorithm</em> (or the
instantiation of an algorithm in the form of a program), and the
<em>space</em> required for a <em>data structure</em>.</p>
<p>Many factors affect the running time of a program. Some relate to the
environment in which the program is compiled and run. Such factors
include the speed of the computer’s CPU, bus, and peripheral hardware.
Competition with other users for the computer’s (or the network’s)
resources can make a program slow to a crawl. The programming language
and the quality of code generated by a particular compiler can have a
significant effect. The “coding efficiency” of the programmer who
converts the algorithm to a program can have a tremendous impact as
well.</p>
<p>If you need to get a program working within time and space
constraints on a particular computer, all of these factors can be
relevant. Yet, none of these factors address the differences between two
algorithms or data structures. To be fair, if you want to compare two
programs derived from two algorithms for solving the same problem, they
should both be compiled with the same compiler and run on the same
computer under the same conditions. As much as possible, the same amount
of care should be taken in the programming effort devoted to each
program to make the implementations “equally efficient”. In this sense,
all of the factors mentioned above should cancel out of the comparison
because they apply to both algorithms equally.</p>
<p>If you truly wish to understand the running time of an algorithm,
there are other factors that are more appropriate to consider than
machine speed, programming language, compiler, and so forth. Ideally we
would measure the running time of the algorithm under standard benchmark
conditions. However, we have no way to calculate the running time
reliably other than to run an implementation of the algorithm on some
computer. The only alternative is to use some other measure as a
surrogate for running time.</p>
</section>
<section id="basic-operations-and-input-size" class="level3"
data-number="3.2.2">
<h3 data-number="3.2.2"><span class="header-section-number">3.2.2</span>
Basic Operations and Input Size</h3>
<p>Of primary consideration when estimating an algorithm’s performance
is the number of <a href="10-glossary.html#basic-operation" class="term"
title="Examples of basic operations include inserting a data item into the data structure, deleting a data item from the data structure, and finding a specified data item.">basic
operations</a> required by the algorithm to process an input of a
certain size. The terms “basic operations” and “size” are both rather
vague and depend on the algorithm being analyzed. Size is often the
number of inputs processed. For example, when comparing sorting
algorithms the size of the problem is typically measured by the number
of records to be sorted. A basic operation must have the property that
its time to complete does not depend on the particular values of its
operands. Adding or comparing two integer variables are examples of
basic operations in most programming languages. Summing the contents of
an array containing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
integers is not, because the cost depends on the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
(i.e., the size of the input).</p>
<div id="SeqMax">
<section id="example" class="level4 unnumbered topic">
<h4 class="unnumbered">Example</h4>
<p>Consider a simple algorithm to solve the problem of finding the
largest value in an array of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
integers. The algorithm looks at each integer in turn, saving the
position of the largest value seen so far. This algorithm is called the
<em>largest-value sequential search</em> and is illustrated by the
following function:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Return position of largest value in integer array A</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> largest(A):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    currlarge <span class="op">=</span> <span class="dv">0</span>                 <span class="co">// Position of largest element seen.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">=</span> <span class="dv">1</span> <span class="kw">to</span> A.<span class="bu">size</span>():     <span class="co">// For each element,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> A[currlarge] <span class="op">&lt;</span> A[i]:   <span class="co">// if A[i] is larger,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            currlarge <span class="op">=</span> i         <span class="co">// remember its position.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> currlarge              <span class="co">// Return largest position</span></span></code></pre></div>
<p>Here, the size of the problem is <code>A.size()</code>, the number of
integers stored in array <code>A</code>. The basic operation is to
compare an integer’s value to that of the largest value seen so far. It
is reasonable to assume that it takes a fixed amount of time to do one
such comparison, regardless of the value of the two integers or their
positions in the array.</p>
<p>Because the most important factor affecting running time is normally
size of the input, for a given input size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
we often express the time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐓</mi><annotation encoding="application/x-tex">\mathbf{T}</annotation></semantics></math>
to run the algorithm as a function of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
written as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T}(n)</annotation></semantics></math>.
We will always assume
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T}(n)</annotation></semantics></math>
is a non-negative value.</p>
<p>Let us call
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
the amount of time required to compare two integers in function
<code>largest</code>. We do not care right now what the precise value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
might be. Nor are we concerned with the time required to increment
variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
because this must be done for each value in the array, or the time for
the actual assignment when a larger value is found, or the little bit of
extra time taken to initialize <code>currlarge</code>. We just want a
reasonable approximation for the time taken to execute the algorithm.
The total time to run <code>largest</code> is therefore approximately
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">cn</annotation></semantics></math>,
because we must make
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
comparisons, with each comparison costing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
time. We say that function <code>largest</code> (and by extension, the
largest-value sequential search algorithm for any typical
implementation) has a running time expressed by the equation</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>c</mi><mi>n</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray}
\mathbf{T}(n) &amp;=&amp; cn
\end{eqnarray}
</annotation></semantics></math></p>
<p>This equation describes the growth rate for the running time of the
largest-value sequential search algorithm.</p>
</section>
</div>
<section id="example-1" class="level4 unnumbered topic">
<h4 class="unnumbered">Example</h4>
<p>The running time of a statement that assigns the first value of an
integer array to a variable is simply the time required to copy the
value of the first array value. We can assume this assignment takes a
constant amount of time regardless of the value. Let us call
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mn>1</mn></msub><annotation encoding="application/x-tex">c_1</annotation></semantics></math>
the amount of time necessary to copy an integer. No matter how large the
array on a typical computer (given reasonable conditions for memory and
array size), the time to copy the value from the first position of the
array is always
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mn>1</mn></msub><annotation encoding="application/x-tex">c_1</annotation></semantics></math>.
Thus, the equation for this algorithm is simply</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mi>c</mi><mn>1</mn></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray}
\mathbf{T}(n) &amp;=&amp; c_1
\end{eqnarray}
</annotation></semantics></math></p>
<p>indicating that the size of the input
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
has no effect on the running time. This is called a <a
href="10-glossary.html#constant-running-time" class="term"
title="The cost of a function whose running time is not related to its input size. In Theta notation, this is traditionally written as $\Theta(1)$.">constant
running time</a>.</p>
</section>
<section id="example-2" class="level4 unnumbered topic">
<h4 class="unnumbered">Example</h4>
<p>Consider the following code:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="bu">sum</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="op">=</span> <span class="dv">0</span> <span class="kw">to</span> n<span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="op">=</span> <span class="dv">0</span> <span class="kw">to</span> n<span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sum</span> <span class="op">=</span> <span class="bu">sum</span><span class="op">+</span><span class="dv">1</span></span></code></pre></div>
<p>What is the running time for this code fragment? Clearly it takes
longer to run when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
is larger. The basic operation in this example is the increment
operation for variable <code>sum</code>. We can assume that incrementing
takes constant time; call this time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mn>2</mn></msub><annotation encoding="application/x-tex">c_2</annotation></semantics></math>.
(We can ignore the time required to initialize <code>sum</code>, and to
increment the loop counters <code>i</code> and <code>j</code>. In
practice, these costs can safely be bundled into time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mn>2</mn></msub><annotation encoding="application/x-tex">c_2</annotation></semantics></math>.)
The total number of increment operations is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mn>2</mn></msup><annotation encoding="application/x-tex">n^2</annotation></semantics></math>.
Thus, we say that the running time is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>c</mi><mn>2</mn></msub><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = c_2 n^2</annotation></semantics></math>.</p>
</section>
</section>
<section id="growth-rates" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3"><span class="header-section-number">3.2.3</span>
Growth Rates</h3>
<p>The <a href="10-glossary.html#growth-rate" class="term"
title="The rate at which a function grows. How quickly the function grows when its input grows. Also called its *order of growth*. A function $f$ has growth rate bounded by a function $g$ if the values of $f$ are eventually bounded by those of $g$ up to some constant factor. We often shorten this (somewhat confusingly) by saying that $f$ has growth rate $g$ or that $f$ has order of growth $g$. Formally, there are constants $n_0 \geq 0$ and $c &gt; 0$ such that $f(n) \leq c g(n)$ for all $n \geq n_0$. We then say that $f$ has growth rate less or equal that of $g$ and write $f \in O(g)$ (big-Oh notation). This defines the preorder of growth rates. In algorithm analysis, we sometimes speak of the growth rate of an algorithm. By that, we mean the growth rate of the complexity of the algorithm, the rate at which the cost of the algorithm grows as the size of its input grows. This is also called the asymptotic complexity of that algorithm.">growth
rate</a> for an algorithm is the rate at which the cost of the algorithm
grows as the size of its input grows. The following figure shows a graph
for six equations, each meant to describe the running time for a
particular program or algorithm. A variety of growth rates that are
representative of typical algorithms are shown.</p>
<div id="RunTimeGraph">
<p>
<div id="GrowthRatesCON" class="ssAV" data-short-name="GrowthRatesCON" data-long-name="DataStructures/Plot.js AlgAnal/GrowthRatesCON" alt="DataStructures/Plot.js AlgAnal/GrowthRatesCON" tabIndex="-1">
<div class="jsavcanvas"></div>
</div>
</p>
<p>
<div id="GrowthRatesZoomCON" class="ssAV" data-short-name="GrowthRatesZoomCON" data-long-name="DataStructures/Plot.js AlgAnal/GrowthRatesZoomCON" alt="DataStructures/Plot.js AlgAnal/GrowthRatesZoomCON" tabIndex="-1">
<div class="jsavcanvas"></div>
</div>
</p>
<p>Two views of a graph illustrating the growth rates for six equations.
The bottom view shows in detail the lower-left portion of the top view.
The horizontal axis represents input size. The vertical axis can
represent time, space, or any other measure of cost.</p>
</div>
<p>The two equations labeled
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">10n</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">20n</annotation></semantics></math>
are graphed by straight lines. A growth rate of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">cn</annotation></semantics></math>
(for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
any positive constant) is often referred to as a <a
href="10-glossary.html#linear-growth-rate" class="term"
title="For input size $n$, a growth rate of $cn$ (for $c$ any positive constant). In other words, the cost of the associated function is linear on the input size.">linear
growth rate</a> or running time. This means that as the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
grows, the running time of the algorithm grows in the same proportion.
Doubling the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
roughly doubles the running time. An algorithm whose running-time
equation has a highest-order term containing a factor of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mn>2</mn></msup><annotation encoding="application/x-tex">n^2</annotation></semantics></math>
is said to have a <a href="10-glossary.html#quadratic-growth-rate"
class="term"
title="A growth rate function of the form $cn^2$ where $n$ is the input size and $c$ is a constant.">quadratic
growth rate</a>. In the figure, the line labeled
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2n^2</annotation></semantics></math>
represents a quadratic growth rate. The line labeled
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>
represents an <a href="10-glossary.html#exponential-growth-rate"
class="term"
title="A growth rate function where $n$ (the input size) appears in the exponent. For example, $2^n$.">exponential
growth rate</a>. This name comes from the fact that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
appears in the exponent. The line labeled
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math>
also grows exponentially.</p>
<p>As you can see from the figure, the difference between an algorithm
whose running time has cost
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = 10n</annotation></semantics></math>
and another with cost
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = 2n^2</annotation></semantics></math>
becomes tremendous as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
grows. For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">n &gt; 5</annotation></semantics></math>,
the algorithm with running time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = 2n^2</annotation></semantics></math>
is already much slower. This is despite the fact that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">10n</annotation></semantics></math>
has a greater constant factor than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2n^2</annotation></semantics></math>.
Comparing the two curves marked
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">20n</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2n^2</annotation></semantics></math>
shows that changing the constant factor for one of the equations only
shifts the point at which the two curves cross. For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">n&gt;10</annotation></semantics></math>,
the algorithm with cost
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = 2n^2</annotation></semantics></math>
is slower than the algorithm with cost
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>20</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = 20n</annotation></semantics></math>.
This graph also shows that the equation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>5</mn><mi>n</mi><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = 5 n \log n</annotation></semantics></math>
grows somewhat more quickly than both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = 10 n</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>20</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = 20 n</annotation></semantics></math>,
but not nearly so quickly as the equation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = 2n^2</annotation></semantics></math>.
For constants
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>&gt;</mo><mn>1</mn><mo>,</mo><msup><mi>n</mi><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">a, b &gt; 1, n^a</annotation></semantics></math>
grows faster than either
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>log</mo><mi>b</mi></msup><mi>n</mi></mrow><annotation encoding="application/x-tex">\log^b n</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><msup><mi>n</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">\log n^b</annotation></semantics></math>.
Finally, algorithms with cost
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = 2^n</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐓</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>n</mi><mi>!</mi></mrow><annotation encoding="application/x-tex">\mathbf{T}(n) = n!</annotation></semantics></math>
are prohibitively expensive for even modest values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>.
Note that for constants
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>≥</mo><mn>1</mn><mo>,</mo><msup><mi>a</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a, b \geq 1, a^n</annotation></semantics></math>
grows faster than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mi>b</mi></msup><annotation encoding="application/x-tex">n^b</annotation></semantics></math>.</p>
<p>We can get some further insight into relative growth rates for
various algorithms from the following table. Most of the growth rates
that appear in typical algorithms are shown, along with some
representative input sizes. Once again, we see that the growth rate has
a tremendous effect on the resources consumed by an algorithm.</p>
<div id="GrowthTable">
<section id="table" class="level4 unnumbered topic">
<h4 class="unnumbered">Table</h4>
<p>Costs for representative growth rates.</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">n</th>
<th
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log\log n</annotation></semantics></math></th>
<th
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></th>
<th
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math></th>
<th
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \log n</annotation></semantics></math></th>
<th
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mn>2</mn></msup><annotation encoding="application/x-tex">n^2</annotation></semantics></math></th>
<th
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mn>3</mn></msup><annotation encoding="application/x-tex">n^3</annotation></semantics></math></th>
<th
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>16</mn><annotation encoding="application/x-tex">16</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>4</mn></msup><annotation encoding="application/x-tex">2^{4}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>⋅</mo><msup><mn>2</mn><mrow><mn>4</mn><mo>=</mo><msup><mn>2</mn><mn>6</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">4 \cdot 2^{4 = 2^{6}}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>8</mn></msup><annotation encoding="application/x-tex">2^{8}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>12</mn></msup><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>16</mn></msup><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>256</mn><annotation encoding="application/x-tex">256</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>8</mn><annotation encoding="application/x-tex">8</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>8</mn></msup><annotation encoding="application/x-tex">2^{8}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>⋅</mo><msup><mn>2</mn><mrow><mn>8</mn><mo>=</mo><msup><mn>2</mn><mn>11</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">8 \cdot 2^{8 = 2^{11}}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>16</mn></msup><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>24</mn></msup><annotation encoding="application/x-tex">2^{24}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>256</mn></msup><annotation encoding="application/x-tex">2^{256}</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1024</mn><annotation encoding="application/x-tex">1024</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>3.3</mn></mrow><annotation encoding="application/x-tex">\approx 3.3</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>10</mn><annotation encoding="application/x-tex">10</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>10</mn></msup><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mo>⋅</mo><msup><mn>2</mn><mrow><mn>10</mn><mo>≈</mo><msup><mn>2</mn><mn>13</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">10 \cdot 2^{10 \approx 2^{13}}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>20</mn></msup><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>30</mn></msup><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>1024</mn></msup><annotation encoding="application/x-tex">2^{1024}</annotation></semantics></math></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn><mi>K</mi></mrow><annotation encoding="application/x-tex">64K</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>16</mn><annotation encoding="application/x-tex">16</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>16</mn></msup><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mo>⋅</mo><msup><mn>2</mn><mrow><mn>16</mn><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">16 \cdot 2^{16 = 2^{20}}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>32</mn></msup><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>48</mn></msup><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mn>64</mn><mi>K</mi></mrow></msup><annotation encoding="application/x-tex">2^{64K}</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>M</mi></mrow><annotation encoding="application/x-tex">1M</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>4.3</mn></mrow><annotation encoding="application/x-tex">\approx 4.3</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>20</mn><annotation encoding="application/x-tex">20</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>20</mn></msup><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mo>⋅</mo><msup><mn>2</mn><mrow><mn>20</mn><mo>≈</mo><msup><mn>2</mn><mn>24</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">20 \cdot 2^{20 \approx 2^{24}}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>40</mn></msup><annotation encoding="application/x-tex">2^{40}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>60</mn></msup><annotation encoding="application/x-tex">2^{60}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mn>1</mn><mi>M</mi></mrow></msup><annotation encoding="application/x-tex">2^{1M}</annotation></semantics></math></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>G</mi></mrow><annotation encoding="application/x-tex">1G</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo><mn>4.9</mn></mrow><annotation encoding="application/x-tex">\approx 4.9</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>30</mn><annotation encoding="application/x-tex">30</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>30</mn></msup><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mo>⋅</mo><msup><mn>2</mn><mrow><mn>30</mn><mo>≈</mo><msup><mn>2</mn><mn>35</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">30 \cdot 2^{30 \approx 2^{35}}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>60</mn></msup><annotation encoding="application/x-tex">2^{60}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>90</mn></msup><annotation encoding="application/x-tex">2^{90}</annotation></semantics></math></td>
<td
style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mn>1</mn><mi>G</mi></mrow></msup><annotation encoding="application/x-tex">2^{1G}</annotation></semantics></math></td>
</tr>
</tbody>
</table>
</section>
</div>
<p>
<div id="CompareGrowth" class="embedContainer">
<iframe id="CompareGrowth_iframe" aria-label="CompareGrowth" src="../interactive/AlgAnal/CompareGrowth.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>
</p>
</section>
<section id="growth-rates-ordering-exercise" class="level3"
data-number="3.2.4">
<h3 data-number="3.2.4"><span class="header-section-number">3.2.4</span>
Growth Rates Ordering Exercise</h3>
<p>
<div id="GrowthRatesPRO" class="embedContainer">
<iframe id="GrowthRatesPRO_iframe" aria-label="GrowthRatesPRO" src="../interactive/AlgAnal/GrowthRatesPRO.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>
</p>
<!-- TODO
To make students more engaged in the GrowthRates exercise, we may need a
tool that allows students to input two growth rate functions. Then the
tool should plot the graph of both functions and mark their crossing
point. The student also should be allowed to play with the constant
values for both functions and see that this only changes the crossing
point but doesn't change which function grows faster than the other. 
-->
</section>
</section>
<script type="text/javascript" src="../interactive/DataStructures/Plot.js"></script>
<script type="text/javascript" src="../interactive/AlgAnal/GrowthRatesCON.js"></script>
<script type="text/javascript" src="../interactive/AlgAnal/GrowthRatesZoomCON.js"></script>
</body>
</html>

