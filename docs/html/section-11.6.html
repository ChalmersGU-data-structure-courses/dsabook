<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Peter Ljunglöf" />
  <meta name="author" content="Alex Gerdes" />
  <meta name="author" content="(editors)" />
  <title>DSABook – Disjoint sets and the Union/Find algorithm</title>
  <link rel="stylesheet" href="../css/main.css" />
  <link rel="stylesheet" href="../css/book.css" />
  <link rel="stylesheet" href="../css/code.css" />
  <link rel="stylesheet" href="../css/math.css" />
  <link rel="stylesheet" href="../css/quiz.css" />
  <link rel="stylesheet" href="../css/mobile.css" />
  <link rel="stylesheet" href="../css/print.css" />
  <style id="dynamicStyleSheet"></style>
  
  <link rel="stylesheet" href="../lib/JSAV.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaMOD.css" type="text/css" />
  <link rel="stylesheet" href="../lib/jquery.ui.min.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaStyle.css" type="text/css" />

  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/javascript" src="../lib/jquery.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.migrate.min.js"></script>
  <script type="text/javascript" src="../lib/localforage.min.js"></script>
  <script type="text/javascript" src="../lib/accessibility.js"></script>
  <script type="text/javascript" src="../lib/jquery.ui.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.transit.js"></script>
  <script type="text/javascript" src="../lib/raphael.js"></script>
  <script type="text/javascript" src="../lib/JSAV.js"></script>
  <script type="text/javascript" src="../lib/config.js"></script>
  <script type="text/javascript" src="../lib/timeme.js"></script>
  <script type="text/javascript" src="../lib/odsaUtils.js"></script>
  <script type="text/javascript" src="../lib/odsaMOD.js"></script>
  <script type="text/javascript" src="../lib/d3.min.js"></script>
  <script type="text/javascript" src="../lib/d3-selection-multi.v1.min.js"></script>
  <script type="text/javascript" src="../lib/dataStructures.js"></script>
  <script type="text/javascript" src="../lib/conceptMap.js"></script>

  <script>
    ODSA.SETTINGS.MODULE_SECTIONS = [
    'internal-variables', 
    'getting-and-setting-values', 
    'adding-elements', 
    'add-practice-exericse', 
    'removing-elements', 
    'remove-practice-exericise', 
    'static-array-based-list-summary-questions', 
    'static-array-based-list:-full-code',
    ];
    ODSA.SETTINGS.MODULE_NAME = "DSABook";
    ODSA.SETTINGS.MODULE_LONG_NAME = "Data Structures and Algorithms";
    JSAV_OPTIONS['lang']='en';
    JSAV_EXERCISE_OPTIONS['code']='pseudo';
  </script>

  
  <script type="text/javascript" src="../scripts/quizhandler.js"></script>
<link href="../interactive/General/UFCON.css" rel="stylesheet" type="text/css"/></head>

<body>

<header>
<nav class="sitenav">
<div></div>
<h1><a href="index.html" class="navbutton" accesskey="t" rel="top">Data Structures and Algorithms</a></h1>
<div></div>
</nav>
<nav class="sitenav">
<div>
<a href="section-11.5.html" class="navbutton">&lt;&lt;</a>
<a href="section-11.5.html" accesskey="p" rel="previous">2-3 trees and B-trees</a>
</div>
<div>
<a href="section-11.7.html" accesskey="n" rel="next">Skip lists</a>
<a href="section-11.7.html" class="navbutton">&gt;&gt;</a>
</div>
</nav>
</header>

<main>
<section id="sec:disjoint-sets" class="level2" data-number="11.6">
<h2 data-number="11.6"><span class="header-section-number">11.6</span>
Disjoint sets and the Union/Find algorithm</h2>
<p><a href="section-14.html#general-tree" class="term"
title="A tree in which any given node can have any number of children. This is in contrast to, for example, a binary tree where each node has a fixed number of children (some of which might be `null`). General tree nodes tend to be harder to implement for this reason.">General
trees</a> (<a href="section-8.6.html#sec:general-trees">Section 8.6</a>)
are trees whose <a href="section-14.html#internal-node" class="term"
title="In a tree, any node that has at least one non-empty child is an internal node.">internal
nodes</a> have no fixed number of <a href="section-14.html#child"
class="term"
title="In a tree, the set of nodes directly pointed to by a node $R$ are the children of $R$.">children</a>.
Compared to general trees, <a href="section-14.html#binary-tree"
class="term"
title="A finite set of nodes which is either empty, or else has a root node together two binary trees, called the left and right subtrees, which are disjoint from each other and from the root.">binary
trees</a> are relatively easy to implement because each internal node of
a binary tree can just store two pointers to reach its (potential)
children. In a general tree, we have to deal with the fact that a given
node might have no children or few children or many children.</p>
<p>Even in a general tree, each node can have only one <a
href="section-14.html#parent" class="term"
title="In a tree, the node $P$ that directly links to a node $A$ is the parent of $A$. $A$ is the child of $P$.">parent</a>.
If we didn’t need to go from a node to its children, but instead only
needed to go from a node to its parent, then implementing a node would
be easy. A simple way to represent such a general tree would be to store
for each node only a pointer to that node’s parent. We will call this
the <a href="section-14.html#parent-pointer-representation" class="term"
title="For trees, a node implementation where each node stores only a pointer to its parent, rather than to its children. This makes it easy to go up the tree toward the root, but not down the tree toward the leaves. This is most appropriate for solving the UNION/FIND problem.">parent
pointer representation</a> for general trees. Clearly this
implementation is not general purpose, because it is inadequate for such
important operations as finding the leftmost child or the right sibling
for a node. Thus, it may seem to be a poor idea to implement a general
tree in this way. However, the parent pointer implementation stores
precisely the information required to answer the following, useful
question: <strong><em>Given two nodes, are they in the same
tree?</em></strong></p>
<div class="online">
<p>To answer this question, we need only follow the series of parent
pointers from each node to its respective root. If both nodes reach the
same root, then they must be in the same tree. If the roots are
different, then the two nodes are not in the same tree.</p>
<section id="sec:parent-pointer-trees" class="level3"
data-number="11.6.1">
<h3 data-number="11.6.1"><span
class="header-section-number">11.6.1</span> Parent pointer trees</h3>
<p>The parent pointer representation is most often used to maintain a
collection of <a href="section-14.html#disjoint-sets" class="term"
title="A collection of sets, any pair of which share no elements in common. A collection of disjoint sets partitions some objects such that every object is in exactly one of the disjoint sets.">disjoint
sets</a>. Two disjoint sets share no members in common (their
intersection is empty). A collection of disjoint sets partitions some
objects such that every object is in exactly one of the disjoint sets.
There are two basic operations that we wish to support:</p>
<ol type="1">
<li>Determine if two objects are in the same set (the
<strong>Find</strong> operation), and</li>
<li>Merge two sets together (the <strong>Union</strong> operation).</li>
</ol>
<p>Because two merged sets are united, the merging operation is called
<strong>Union</strong> and the whole process of determining if two
objects are in the same set and then merging the sets goes by the name
<strong><a href="section-14.html#union-find" class="term"
title="A process for mainining a collection of disjoint sets. The FIND operation determines which disjoint set a given object resides in, and the UNION operation combines two disjoint sets when it is determined that they are members of the same equivalence class under some equivalence relation.">Union/Find</a></strong>.</p>
<p>To implement <strong>Union/Find</strong>, we represent each disjoint
set with a separate general tree. Two objects are in the same disjoint
set if they are in the same tree. Every node of the tree (except for the
root) has precisely one parent. Thus, each node requires the same space
to represent it. The collection of objects is typically stored in an
array, where each element of the array corresponds to one object, and
each element stores the object’s value (or a pointer to the object). The
objects also correspond to nodes in the various disjoint trees (one tree
for each disjoint set), so we also store the parent value with each
object in the array. Those nodes that are the roots of their respective
trees store an appropriate indicator. Note that this representation
means that a single array is being used to implement a collection of
trees. This makes it easy to merge trees together with
<strong>Union</strong> operations.</p>
<p>Here is an implementation for parent pointer trees and the
<strong>Union/Find</strong> process.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// General tree implementation for Union/Find</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> ParentPointerTree:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    array: <span class="bu">Array</span> <span class="kw">of</span> <span class="bu">Int</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constructor</span>(<span class="bu">size</span>):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Each node is its own root to start</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        array <span class="op">=</span> <span class="kw">new</span> <span class="bu">Array</span>(<span class="bu">size</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">0</span> .. <span class="bu">size</span><span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            array[i] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>  <span class="co">// We use -1 to say that this is a root</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Merge two subtrees if they are different:</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    union(a: <span class="bu">Int</span>, b: <span class="bu">Int</span>):</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        root1 <span class="op">=</span> find(a)    <span class="co">// Find root of node a</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        root2 <span class="op">=</span> find(b)    <span class="co">// Find root of node b</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> root1 <span class="op">!=</span> root2: <span class="co">// Merge two trees</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            array[root1] <span class="op">=</span> root2</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return the root of current&#39;s tree</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    find(current: <span class="bu">Int</span>) <span class="op">-&gt;</span> <span class="bu">Int</span>:</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> array[current] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> self.array[current]</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> current  <span class="co">// Now we are at the root</span></span></code></pre></div>
<p>The <code>ParentPointerTree</code> class has an array where each
array position corresponds to one object in some collection. Each array
element stores the array index for its parent. There are two main
methods to implement. <strong>Union</strong> merges two sets together,
where each set corresponds to a tree. <strong>Find</strong> is used to
find the ultimate root for a node.</p>
<p>An application using the <strong>Union/Find</strong> operations
should store a set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
objects, where each object is assigned a unique index in the range 0 to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>.
The indices refer to the corresponding parent pointers in the array.
Class <code>ParentPointerTree</code> creates and initialises the
<strong>Union/Find</strong> array, and methods <strong>Union</strong>
and <strong>Find</strong> take array indices as inputs. <a
href="#fig:UFfig">Figure 11.13</a> visualises the parent pointer
array.</p>
<figure id="fig:UFfig">

<div id="UFfigCON" class="ssAV" data-short-name="UFfigCON" data-long-name="UFfigCON" alt="UFfigCON" tabIndex="-1">
<div class="jsavcanvas"></div>
</div>

<script type="text/javascript" src="../interactive/General/UFfigCON.js"></script>
<script>
  $(document).ready(function(){
    function NewAV() {return new JSAV("UFfigCON", {animationMode: "none"})}
    function AddCSS(rule) {document.getElementById("dynamicStyleSheet").sheet.insertRule("#UFfigCON "+rule)}
    
  });
</script>

<figcaption><p>Figure 11.13: The parent pointer array implementation.
Each node corresponds to a position in the node array, which stores its
value and a pointer to its parent. The parent pointers are represented
by an array index corresponding to the position of the parent. The root
of any tree stores a special value, such as -1. This is represented
graphically in the figure by a slash in the “Parent’s Index” box. This
figure shows two trees stored in the same parent pointer array, one
rooted at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
(with a total of 9 nodes), and the other rooted at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
(with a total of 1 node).</p></figcaption>
</figure>
</section>
<section id="sec:equivalence-classes" class="level3"
data-number="11.6.2">
<h3 data-number="11.6.2"><span
class="header-section-number">11.6.2</span> Equivalence classes</h3>
<p>Consider the problem of assigning the members of a set to disjoint
subsets called <a href="section-14.html#equivalence-class" class="term"
title="An equivalence relation can be used to partition a set into equivalence classes.">equivalence
classes</a>. Recall that an <a
href="section-14.html#equivalence-relation" class="term"
title="Relation $R$ is an equivalence relation on set $\mathbf{S}$ if it is reflexive, symmetric, and transitive.">equivalence
relation</a> is <a href="section-14.html#reflexive" class="term"
title="In set notation, binary relation $R$ on set $S$ is reflexive if $aRa$ for all $a \in \mathbf{S}$.">reflexive</a>,
<a href="section-14.html#symmetric" class="term"
title="In set notation, relation $R$ is symmetric if whenever $aRb$, then $bRa$, for all $a, b \in \mathbf{S}$.">symmetric</a>,
and <a href="section-14.html#transitive" class="term"
title="In set notation, relation $R$ is transitive if whenever $aRb$ and $bRc$, then $aRc$, for all $a, b, c \in \mathbf{S}$.">transitive</a>.
Thus, if objects
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
are equivalent, and objects
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
are equivalent, then we must be able to recognise that objects
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
are also equivalent. In this representation, since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
are equivalent, they must be in the same tree. Likewise for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>.
We can recognise that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
are equivalent because they must also be in the same tree.</p>
<p>There are many practical uses for disjoint sets and representing
equivalences. For example, consider the graph of ten nodes labeled
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
through
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>,
in <a href="#fig:UFconcom">Figure 11.14</a>.</p>
<figure id="fig:UFconcom">

<div id="UFconcomCON" class="ssAV" data-short-name="UFconcomCON" data-long-name="UFconcomCON" alt="UFconcomCON" tabIndex="-1">
<div class="jsavcanvas"></div>
</div>

<script type="text/javascript" src="../interactive/General/UFconcomCON.js"></script>
<script>
  $(document).ready(function(){
    function NewAV() {return new JSAV("UFconcomCON", {animationMode: "none"})}
    function AddCSS(rule) {document.getElementById("dynamicStyleSheet").sheet.insertRule("#UFconcomCON "+rule)}
    
  });
</script>

<figcaption><p>Figure 11.14: A graph with two connected components. The
tree of <a href="#fig:UFfig">Figure 11.13</a> shows the corresponding
tree structure resulting form processing the edges to determine the
connected components.</p></figcaption>
</figure>
<p>Notice that for nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
through
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>,
there is some series of edges that connects any pair of these nodes, but
node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
is disconnected from the rest of the nodes. Such a graph might be used
to represent connections such as wires between components on a circuit
board, or roads between cities. We can consider two nodes of the graph
to be equivalent if there is a path between them. Thus, nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi><annotation encoding="application/x-tex">E</annotation></semantics></math>
would be considered as equivalent, but
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
is not equivalent to any other. A subset of equivalent (connected) edges
in a graph is called a <a href="section-14.html#connected-component"
class="term"
title="In an undirected graph, a subset of the nodes such that each node in the subset can be reached from any other node in that subset.">connected
component</a>. The goal is to quickly classify the objects into disjoint
sets that correspond to the connected components.</p>
<p>Another use for disjoint sets occurs in <a
href="section-14.html#kruskals-algorithm" class="term"
title="An algorithm for computing the MST of a graph. During processing, it makes use of the UNION/FIND process to efficiently determine of two vertices are within the same subgraph.">Kruskal’s
algorithm</a> for computing the <a
href="section-14.html#minimum-spanning-tree" class="term"
title="Abbreviated as MST, or sometimes as MCST. Derived from a weighted graph, the MST is the subset of the graph&#39;s edges that maintains the connectivitiy of the graph while having lowest total cost (as defined by the sum of the weights of the edges in the MST). The result is referred to as a tree because it would never have a cycle (since an edge could be removed from the cycle and still preserve connectivity). Two algorithms to solve this problem are Prim&#39;s algorithm and Kruskal&#39;s algorithm.">minimum
spanning tree</a> for a <a href="section-14.html#graph" class="term"
title="A graph $\mathbf{G} = (\mathbf{V}, \mathbf{E})$ consists of a set of vertices $\mathbf{V}$ and a set of edges $\mathbf{E}$, such that each edge in $\mathbf{E}$ is a connection between a pair of vertices in $\mathbf{V}$.">graph</a>.
That algorithm seeks to select the cheapest subset of the edges that
still connects all of the nodes in the graph. It does so by processing
all edges of the graph from shortest to longest, only adding an edge to
the connecting subset if it does not connect two nodes that already have
some series of edges connecting them.</p>
<p>The input to the <strong>Union/Find</strong> algorithm is typically a
series of equivalence pairs. In the case of the connected components
example, the equivalence pairs would simply be the set of edges in the
graph. An equivalence pair might say that object
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
is equivalent to object
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.
If so,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
are placed in the same subset. If a later equivalence relates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>,
then by implication
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>
is also equivalent to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>.
Thus, an equivalence pair may cause two subsets to merge, each of which
contains several objects.</p>
<p>Equivalence classes can be managed efficiently with the
<strong>Union/Find</strong> algorithm. Initially, each object is at the
root of its own tree. An equivalence pair is processed by checking to
see if both objects of the pair are in the same tree by calling
<strong>Find</strong> on each of them. If their roots are the same, then
no change need be made because the objects are already in the same
equivalence class. Otherwise, the two equivalence classes should be
merged by the <strong>Union</strong> method.</p>
<p>The parent pointer representation places no limit on the number of
nodes that can share a parent. To make equivalence processing as
efficient as possible, the distance from each node to the root of its
respective tree should be as small as possible. Thus, we would like to
keep the height of the trees small when merging two equivalence classes
together. Ideally, each tree would have all nodes pointing directly to
the root. Achieving this goal all the time would require too much
additional processing to be worth the effort, so we must settle for
getting as close as possible.</p>
</section>
<section id="sec:weighted-union" class="level3" data-number="11.6.3">
<h3 data-number="11.6.3"><span
class="header-section-number">11.6.3</span> Weighted union</h3>
<p>A low-cost approach to reducing the height is to be smart about how
two trees are joined together. One simple technique, called the <a
href="section-14.html#weighted-union-rule" class="term"
title="When merging two disjoint sets using the UNION/FIND algorithm, the weighted union rule is used to determine which subtree&#39;s root points to the other. The root of the subtree with fewer nodes will be set to point to the root of the subtree with more nodes. In this way, the average depth of nodes in the resulting tree will be less than if the assignment had been made in the other direction.">weighted
union rule</a>, joins the tree with fewer nodes to the tree with more
nodes by making the smaller tree’s root point to the root of the bigger
tree. This will limit the total depth of the tree to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math>,
because the depth of nodes only in the smaller tree will now increase by
one, and the depth of the deepest node in the combined tree can only be
at most one deeper than the deepest node before the trees were combined.
The total number of nodes in the combined tree is therefore at least
twice the number in the smaller subtree. Thus, the depth of any node can
be increased at most
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math>
times when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
equivalences are processed (since each addition to the depth must be
accompanied by at least doubling the size of the tree).</p>
<p>Here is an implementation for <strong>Union</strong> when using
weighted union.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> ParentPointerTree:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    union(a, b):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        root1 <span class="op">=</span> find(a)     <span class="co">// Find root of node a</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        root2 <span class="op">=</span> find(b)     <span class="co">// Find root of node b</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> root1 <span class="op">!=</span> root2:  <span class="co">// Merge with weighted union</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> weights[root2] <span class="op">&gt;</span> weights[root1]:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                array[root1] <span class="op">=</span> root2</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                weights[root2] <span class="op">=</span> weights[root2] <span class="op">+</span> weights[root1]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                array[root2] <span class="op">=</span> root1</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                weights[root1] <span class="op">=</span> weights[root1] <span class="op">+</span> weights[root2]</span></code></pre></div>
<div class="dsvis">
<details open="true">
<summary>
<p>The following slideshow illustrates a series of
<strong>Union</strong> operations with weighted union.</p>
</summary>

<div id="UFCON" class="ssAV" data-short-name="UFCON" data-long-name="Union/Find Example" alt="Union/Find Example" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>

<script type="text/javascript" src="../interactive/General/UFCON.js"></script>
<script>
  $(document).ready(function(){
    function NewAV() {return new JSAV("UFCON", {animationMode: "none"})}
    function AddCSS(rule) {document.getElementById("dynamicStyleSheet").sheet.insertRule("#UFCON "+rule)}
    
  });
</script>

</details>
</div>
</section>
<section id="sec:path-compression" class="level3" data-number="11.6.4">
<h3 data-number="11.6.4"><span
class="header-section-number">11.6.4</span> Path compression</h3>
<p>The weighted union rule helps to minimise the depth of the tree, but
we can do better than this. <a href="section-14.html#path-compression"
class="term"
title="When implementing the UNION/FIND algorithm, path compression is a local optimisation step that can be performed during the FIND step. Once the root of the tree for the current object has been found, the path to the root can be traced a second time, with all objects in the tree made to point directly to the root. This reduces the depth of the tree from typically $O(\log n)$ to nearly constant.">Path
compression</a> is a method that tends to create extremely shallow
trees. Path compression takes place while finding the root for a given
node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>.
Call this root
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>.
Path compression resets the parent of every node on the path from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
to point directly to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>.
This can be implemented by first finding
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>.
A second pass is then made along the path from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>,
assigning the parent field of each node encountered to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>.
Alternatively, a recursive algorithm can be implemented as follows. This
version of <strong>Find</strong> not only returns the root of the
current node, but also makes all ancestors of the current node point to
the root.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> ParentPointerTree:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return the root of current&#39;s tree with path compression</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    find(current):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> array[current] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> current  <span class="co">// Base case: we are at the root</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            array[current] <span class="op">=</span> find(array[current])</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> array[current]</span></code></pre></div>
<div class="dsvis">
<details open="true">
<summary>
<p>The following slide show illustrates path compression using the last
step in the previous example.</p>
</summary>

<div id="pathcompCON" class="ssAV" data-short-name="pathcompCON" data-long-name="Union/Find Path Compression Example" alt="Union/Find Path Compression Example" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>

<script type="text/javascript" src="../interactive/General/pathcompCON.js"></script>
<script>
  $(document).ready(function(){
    function NewAV() {return new JSAV("pathcompCON", {animationMode: "none"})}
    function AddCSS(rule) {document.getElementById("dynamicStyleSheet").sheet.insertRule("#pathcompCON "+rule)}
    
  });
</script>

</details>
</div>
<p>Path compression keeps the cost of each <strong>Find</strong>
operation very close to constant.</p>
<p>To be more precise about what is meant by “very close to constant”,
the cost of path compression for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
<strong>Find</strong> operations on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
nodes (when combined with the weighted union rule for joining sets) is
approximately
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><msup><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mo>*</mo></msup><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n \log^* n)</annotation></semantics></math>.
The notation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mo>*</mo></msup><mi>n</mi></mrow><annotation encoding="application/x-tex">\log^* n</annotation></semantics></math>
means the number of times that the log of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
must be taken before
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \leq 1</annotation></semantics></math>.
For example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mo>*</mo></msup><mn>65536</mn></mrow><annotation encoding="application/x-tex">\log^* 65536</annotation></semantics></math>
is 4 because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mn>65536</mn><mo>=</mo><mn>16</mn><mo>,</mo><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mn>16</mn><mo>=</mo><mn>4</mn><mo>,</mo><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mn>4</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\log 65536 = 16, \log 16 = 4, \log 4 = 2</annotation></semantics></math>,
and finally
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mn>2</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\log 2 = 1</annotation></semantics></math>.
Thus,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mo>*</mo></msup><mi>n</mi></mrow><annotation encoding="application/x-tex">\log^* n</annotation></semantics></math>
grows <em>very</em> slowly, so the cost for a series of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
<strong>Find</strong> operations is very close to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>.</p>
<p>Note that this does not mean that the tree resulting from processing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
equivalence pairs necessarily has depth
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><msup><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mo>*</mo></msup><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(\log^* n)</annotation></semantics></math>.
One can devise a series of equivalence operations that yields
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math>
depth for the resulting tree. However, many of the equivalences in such
a series will look only at the roots of the trees being merged,
requiring little processing time. The <em>total</em> amount of
processing time required for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
operations will be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><msup><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mo>*</mo></msup><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n \log^* n)</annotation></semantics></math>,
yielding nearly constant time for each equivalence operation. This is an
example of <a href="section-14.html#amortised-analysis" class="term"
title="Analysing the amortised complexity of an algorithm or problem.">amortised
analysis</a>.</p>
<div class="dsvis">
<details open="true">
<summary>
<p>Union/Find practise exercise.</p>
</summary>

<div id="UnionFindPRO" class="embedContainer">
<iframe id="UnionFindPRO_iframe" aria-label="UnionFindPRO" src="../interactive/General/UnionFindPRO.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>

</details>
</div>
</section>
</div>
</section>
</main>

<footer>
<nav class="sitenav">
<div class="navlink">
<a href="section-11.5.html" class="navbutton">&lt;&lt;</a>
<a href="section-11.5.html" accesskey="p" rel="previous">2-3 trees and B-trees</a>
</div>
<div class="navlink">
<a href="section-11.7.html" accesskey="n" rel="next">Skip lists</a>
<a href="section-11.7.html" class="navbutton">&gt;&gt;</a>
</div>
</nav>
</footer>

</body>
</html>


