<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Cliff Shaffer" />
  <meta name="author" content="Peter Ljunglöf" />
  <meta name="author" content="Nick Smallbone" />
  <title>DSABook – Heaps and Priority Queues</title>
  <style>
    div.sitenav { display: flex; flex-direction: row; flex-wrap: wrap; }
    span.navlink { flex: 1; }
    span.navlink-label { display: inline-block; min-width: 4em; }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        background-color: #ffffff;
        color: #a0a0a0;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
    div.sourceCode
      { color: #1f1c1b; background-color: #ffffff; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #1f1c1b; } /* Normal */
    code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
    code span.an { color: #ca60ca; } /* Annotation */
    code span.at { color: #0057ae; } /* Attribute */
    code span.bn { color: #b08000; } /* BaseN */
    code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
    code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #924c9d; } /* Char */
    code span.cn { color: #aa5500; } /* Constant */
    code span.co { color: #898887; } /* Comment */
    code span.cv { color: #0095ff; } /* CommentVar */
    code span.do { color: #607880; } /* Documentation */
    code span.dt { color: #0057ae; } /* DataType */
    code span.dv { color: #b08000; } /* DecVal */
    code span.er { color: #bf0303; text-decoration: underline; } /* Error */
    code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
    code span.fl { color: #b08000; } /* Float */
    code span.fu { color: #644a9b; } /* Function */
    code span.im { color: #ff5500; } /* Import */
    code span.in { color: #b08000; } /* Information */
    code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
    code span.op { color: #1f1c1b; } /* Operator */
    code span.ot { color: #006e28; } /* Other */
    code span.pp { color: #006e28; } /* Preprocessor */
    code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
    code span.sc { color: #3daee9; } /* SpecialChar */
    code span.ss { color: #ff5500; } /* SpecialString */
    code span.st { color: #bf0303; } /* String */
    code span.va { color: #0057ae; } /* Variable */
    code span.vs { color: #bf0303; } /* VerbatimString */
    code span.wa { color: #bf0303; } /* Warning */
  </style>
  <link rel="stylesheet" href="../bookstyle.css" />
  
  <link rel="stylesheet" href="../lib/JSAV.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaMOD.css" type="text/css" />
  <link rel="stylesheet" href="../lib/jquery.ui.min.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaStyle.css" type="text/css" />
  <link rel="stylesheet" href="../lib/ChalmersGU-interactive.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">


  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
      },
      "HTML-CSS": {
        scale: "80",
      }
    });
  </script>

  <script type="text/javascript" src="../lib/jquery.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.migrate.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src="../lib/localforage.min.js"></script>
  <script type="text/javascript" src="../lib/accessibility.js"></script>
  <script type="text/javascript" src="../lib/jquery.ui.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.transit.js"></script>
  <script type="text/javascript" src="../lib/raphael.js"></script>
  <script type="text/javascript" src="../lib/JSAV.js"></script>
  <script type="text/javascript" src="../lib/config.js"></script>
  <script type="text/javascript" src="../lib/timeme.js"></script>
  <script type="text/javascript" src="../lib/odsaUtils.js"></script>
  <script type="text/javascript" src="../lib/odsaMOD.js"></script>
  <script type="text/javascript" src="../lib/d3.min.js"></script>
  <script type="text/javascript" src="../lib/d3-selection-multi.v1.min.js"></script>
  <script type="text/javascript" src="../lib/dataStructures.js"></script>
  <script type="text/javascript" src="../lib/conceptMap.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js" integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+" crossorigin="anonymous"></script>
  <script src="../scroll-toc.js"></script>

  <script>
    ODSA.SETTINGS.MODULE_SECTIONS = [
    'internal-variables', 
    'getting-and-setting-values', 
    'adding-elements', 
    'add-practice-exericse', 
    'removing-elements', 
    'remove-practice-exericise', 
    'static-array-based-list-summary-questions', 
    'static-array-based-list:-full-code',
    ];
    ODSA.SETTINGS.MODULE_NAME = "DSABook";
    ODSA.SETTINGS.MODULE_LONG_NAME = "Data Structures and Algorithms";
    JSAV_OPTIONS['lang']='en';
    JSAV_EXERCISE_OPTIONS['code']='pseudo';
  </script>

<link href="../interactive/Binary/HeapBldChoiceCON.css" rel="stylesheet" type="text/css"/>
<link href="../interactive/Binary/HeapsIndCON.css" rel="stylesheet" type="text/css"/>
<link href="../interactive/Binary/heapbuildProofCON.css" rel="stylesheet" type="text/css"/>
</head>
<body><div class="row">
<div class="col-3"><nav id="TOC" role="doc-toc" class="nav-scroll-header"><div class="nav-scroll">
<ul>
<li><a href="1-introduction.html#introduction"
id="toc-introduction"><span class="toc-section-number">1</span>
Introduction</a>
<ul>
<li><a
href="1.1-selecting-a-data-structure.html#selecting-a-data-structure"
id="toc-selecting-a-data-structure"><span
class="toc-section-number">1.1</span> Selecting a Data
Structure</a></li>
<li><a href="1.2-abstract-data-types.html#abstract-data-types"
id="toc-abstract-data-types"><span class="toc-section-number">1.2</span>
Abstract Data Types</a></li>
<li><a
href="1.3-all-adts-used-in-this-book.html#all-adts-used-in-this-book"
id="toc-all-adts-used-in-this-book"><span
class="toc-section-number">1.3</span> All ADTs Used in This
Book</a></li>
<li><a
href="1.4-information-retrieval-sets-and-maps.html#information-retrieval-sets-and-maps"
id="toc-information-retrieval-sets-and-maps"><span
class="toc-section-number">1.4</span> Information retrieval: Sets and
Maps</a></li>
<li><a
href="1.5-comparables-comparators-and-key-value-pairs.html#comparables-comparators-and-key-value-pairs"
id="toc-comparables-comparators-and-key-value-pairs"><span
class="toc-section-number">1.5</span> Comparables, Comparators and
Key-Value Pairs</a></li>
<li><a
href="1.6-comparables-and-comparators-an-example.html#comparables-and-comparators-an-example"
id="toc-comparables-and-comparators-an-example"><span
class="toc-section-number">1.6</span> Comparables and Comparators: An
Example</a></li>
</ul></li>
<li><a
href="2-arrays-searching-and-sorting.html#arrays-searching-and-sorting"
id="toc-arrays-searching-and-sorting"><span
class="toc-section-number">2</span> Arrays: searching and sorting</a>
<ul>
<li><a href="2.1-searching-in-an-array.html#searching-in-an-array"
id="toc-searching-in-an-array"><span
class="toc-section-number">2.1</span> Searching in an Array</a></li>
<li><a href="2.2-sorting.html#sorting" id="toc-sorting"><span
class="toc-section-number">2.2</span> Sorting</a></li>
<li><a
href="2.3-sorting-terminology-and-notation.html#sorting-terminology-and-notation"
id="toc-sorting-terminology-and-notation"><span
class="toc-section-number">2.3</span> Sorting Terminology and
Notation</a></li>
<li><a href="2.4-insertion-sort.html#insertion-sort"
id="toc-insertion-sort"><span class="toc-section-number">2.4</span>
Insertion Sort</a></li>
<li><a href="2.5-bubble-sort-optional.html#bubble-sort-optional"
id="toc-bubble-sort-optional"><span
class="toc-section-number">2.5</span> Bubble Sort (optional)</a></li>
<li><a href="2.6-selection-sort.html#selection-sort"
id="toc-selection-sort"><span class="toc-section-number">2.6</span>
Selection Sort</a></li>
<li><a
href="2.7-the-cost-of-exchange-sorting-optional.html#the-cost-of-exchange-sorting-optional"
id="toc-the-cost-of-exchange-sorting-optional"><span
class="toc-section-number">2.7</span> The Cost of Exchange Sorting
(optional)</a></li>
<li><a
href="2.8-optimizing-sort-algorithms-with-code-tuning-optional.html#optimizing-sort-algorithms-with-code-tuning-optional"
id="toc-optimizing-sort-algorithms-with-code-tuning-optional"><span
class="toc-section-number">2.8</span> Optimizing Sort Algorithms with
Code Tuning (optional)</a></li>
<li><a href="2.9-mergesort.html#mergesort" id="toc-mergesort"><span
class="toc-section-number">2.9</span> Mergesort</a></li>
<li><a href="2.10-implementing-mergesort.html#implementing-mergesort"
id="toc-implementing-mergesort"><span
class="toc-section-number">2.10</span> Implementing Mergesort</a></li>
<li><a href="2.11-quicksort.html#quicksort" id="toc-quicksort"><span
class="toc-section-number">2.11</span> Quicksort</a></li>
<li><a
href="2.12-an-empirical-comparison-of-sorting-algorithms.html#an-empirical-comparison-of-sorting-algorithms"
id="toc-an-empirical-comparison-of-sorting-algorithms"><span
class="toc-section-number">2.12</span> An Empirical Comparison of
Sorting Algorithms</a></li>
<li><a
href="2.13-lower-bounds-for-sorting-optional.html#lower-bounds-for-sorting-optional"
id="toc-lower-bounds-for-sorting-optional"><span
class="toc-section-number">2.13</span> Lower Bounds for Sorting
(optional)</a></li>
<li><a href="2.14-arrays-as-sets-or-maps.html#arrays-as-sets-or-maps"
id="toc-arrays-as-sets-or-maps"><span
class="toc-section-number">2.14</span> Arrays as Sets or Maps</a></li>
<li><a
href="2.15-sorting-summary-exercises.html#sorting-summary-exercises"
id="toc-sorting-summary-exercises"><span
class="toc-section-number">2.15</span> Sorting: Summary
Exercises</a></li>
</ul></li>
<li><a href="3-algorithm-analysis.html#algorithm-analysis"
id="toc-algorithm-analysis"><span class="toc-section-number">3</span>
Algorithm Analysis</a>
<ul>
<li><a
href="3.1-problems-algorithms-and-programs.html#problems-algorithms-and-programs"
id="toc-problems-algorithms-and-programs"><span
class="toc-section-number">3.1</span> Problems, Algorithms, and
Programs</a></li>
<li><a href="3.2-comparing-algorithms.html#comparing-algorithms"
id="toc-comparing-algorithms"><span
class="toc-section-number">3.2</span> Comparing Algorithms</a></li>
<li><a
href="3.3-best-worst-and-average-cases.html#best-worst-and-average-cases"
id="toc-best-worst-and-average-cases"><span
class="toc-section-number">3.3</span> Best, Worst, and Average
Cases</a></li>
<li><a
href="3.4-faster-computer-or-faster-algorithm.html#faster-computer-or-faster-algorithm"
id="toc-faster-computer-or-faster-algorithm"><span
class="toc-section-number">3.4</span> Faster Computer, or Faster
Algorithm?</a></li>
<li><a
href="3.5-asymptotic-analysis-and-upper-bounds.html#asymptotic-analysis-and-upper-bounds"
id="toc-asymptotic-analysis-and-upper-bounds"><span
class="toc-section-number">3.5</span> Asymptotic Analysis and Upper
Bounds</a></li>
<li><a
href="3.6-lower-bounds-and-theta-notation.html#lower-bounds-and-theta-notation"
id="toc-lower-bounds-and-theta-notation"><span
class="toc-section-number">3.6</span> Lower Bounds and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Θ</mi><annotation encoding="application/x-tex">\Theta</annotation></semantics></math>
Notation</a></li>
<li><a
href="3.7-calculating-program-running-time.html#calculating-program-running-time"
id="toc-calculating-program-running-time"><span
class="toc-section-number">3.7</span> Calculating Program Running
Time</a></li>
<li><a href="3.8-analyzing-problems.html#analyzing-problems"
id="toc-analyzing-problems"><span class="toc-section-number">3.8</span>
Analyzing Problems</a></li>
<li><a href="3.9-common-misunderstandings.html#common-misunderstandings"
id="toc-common-misunderstandings"><span
class="toc-section-number">3.9</span> Common Misunderstandings</a></li>
<li><a href="3.10-multiple-parameters.html#multiple-parameters"
id="toc-multiple-parameters"><span
class="toc-section-number">3.10</span> Multiple Parameters</a></li>
<li><a href="3.11-space-bounds.html#space-bounds"
id="toc-space-bounds"><span class="toc-section-number">3.11</span> Space
Bounds</a></li>
<li><a
href="3.12-code-tuning-and-empirical-analysis.html#code-tuning-and-empirical-analysis"
id="toc-code-tuning-and-empirical-analysis"><span
class="toc-section-number">3.12</span> Code Tuning and Empirical
Analysis</a></li>
<li><a
href="3.13-algorithm-analysis-summary-exercises.html#algorithm-analysis-summary-exercises"
id="toc-algorithm-analysis-summary-exercises"><span
class="toc-section-number">3.13</span> Algorithm Analysis: Summary
Exercises</a></li>
<li><a href="3.14-summary-exercise-cs3.html#summary-exercise-cs3"
id="toc-summary-exercise-cs3"><span
class="toc-section-number">3.14</span> Summary Exercise: CS3</a></li>
<li><a
href="3.15-growth-rates-review-optional-work-in-progress.html#growth-rates-review-optional-work-in-progress"
id="toc-growth-rates-review-optional-work-in-progress"><span
class="toc-section-number">3.15</span> Growth Rates Review (optional)
(WORK IN PROGRESS)</a></li>
<li><a
href="3.16-summation-techniques-optional-work-in-progress.html#summation-techniques-optional-work-in-progress"
id="toc-summation-techniques-optional-work-in-progress"><span
class="toc-section-number">3.16</span> Summation Techniques (optional)
(WORK IN PROGRESS)</a></li>
<li><a
href="3.17-solving-recurrence-relations-optional-work-in-progress.html#solving-recurrence-relations-optional-work-in-progress"
id="toc-solving-recurrence-relations-optional-work-in-progress"><span
class="toc-section-number">3.17</span> Solving Recurrence Relations
(optional) (WORK IN PROGRESS)</a></li>
<li><a
href="3.18-amortized-analysis-optional-work-in-progress.html#amortized-analysis-optional-work-in-progress"
id="toc-amortized-analysis-optional-work-in-progress"><span
class="toc-section-number">3.18</span> Amortized Analysis (optional)
(WORK IN PROGRESS)</a></li>
</ul></li>
<li><a href="4-lists-1.html#lists-1" id="toc-lists-1"><span
class="toc-section-number">4</span> Lists</a>
<ul>
<li><a href="4.1-the-list-adt.html#the-list-adt"
id="toc-the-list-adt"><span class="toc-section-number">4.1</span> The
List ADT</a></li>
<li><a href="4.2-static-array-based-lists.html#static-array-based-lists"
id="toc-static-array-based-lists"><span
class="toc-section-number">4.2</span> Static Array-Based Lists</a></li>
<li><a
href="4.3-dynamic-array-based-lists.html#dynamic-array-based-lists"
id="toc-dynamic-array-based-lists"><span
class="toc-section-number">4.3</span> Dynamic Array-Based Lists</a></li>
<li><a href="4.4-linked-lists.html#linked-lists"
id="toc-linked-lists"><span class="toc-section-number">4.4</span> Linked
Lists</a></li>
<li><a
href="4.5-comparison-of-list-implementations.html#comparison-of-list-implementations"
id="toc-comparison-of-list-implementations"><span
class="toc-section-number">4.5</span> Comparison of List
Implementations</a></li>
<li><a
href="4.6-implementing-maps-using-lists.html#implementing-maps-using-lists"
id="toc-implementing-maps-using-lists"><span
class="toc-section-number">4.6</span> Implementing Maps using
Lists</a></li>
<li><a
href="4.7-doubly-linked-lists-optional.html#doubly-linked-lists-optional"
id="toc-doubly-linked-lists-optional"><span
class="toc-section-number">4.7</span> Doubly Linked Lists
(optional)</a></li>
<li><a href="4.8-stacks.html#stacks" id="toc-stacks"><span
class="toc-section-number">4.8</span> Stacks</a></li>
<li><a href="4.9-implementing-recursion.html#implementing-recursion"
id="toc-implementing-recursion"><span
class="toc-section-number">4.9</span> Implementing Recursion</a></li>
<li><a href="4.10-queues.html#queues" id="toc-queues"><span
class="toc-section-number">4.10</span> Queues</a></li>
<li><a
href="4.11-linear-structure-summary-exercises.html#linear-structure-summary-exercises"
id="toc-linear-structure-summary-exercises"><span
class="toc-section-number">4.11</span> Linear Structure Summary
Exercises</a></li>
</ul></li>
<li><a href="5-binary-trees.html#binary-trees"
id="toc-binary-trees"><span class="toc-section-number">5</span> Binary
Trees</a>
<ul>
<li><a
href="5.1-definitions-and-properties.html#definitions-and-properties"
id="toc-definitions-and-properties"><span
class="toc-section-number">5.1</span> Definitions and
Properties</a></li>
<li><a
href="5.2-binary-tree-as-a-recursive-data-structure.html#binary-tree-as-a-recursive-data-structure"
id="toc-binary-tree-as-a-recursive-data-structure"><span
class="toc-section-number">5.2</span> Binary Tree as a Recursive Data
Structure</a></li>
<li><a
href="5.3-binary-tree-node-implementations.html#binary-tree-node-implementations"
id="toc-binary-tree-node-implementations"><span
class="toc-section-number">5.3</span> Binary Tree Node
Implementations</a></li>
<li><a
href="5.4-the-full-binary-tree-theorem-optional.html#the-full-binary-tree-theorem-optional"
id="toc-the-full-binary-tree-theorem-optional"><span
class="toc-section-number">5.4</span> The Full Binary Tree Theorem
(optional)</a></li>
<li><a href="5.5-binary-tree-traversals.html#binary-tree-traversals"
id="toc-binary-tree-traversals"><span
class="toc-section-number">5.5</span> Binary Tree Traversals</a></li>
<li><a
href="5.6-implementing-tree-traversals.html#implementing-tree-traversals"
id="toc-implementing-tree-traversals"><span
class="toc-section-number">5.6</span> Implementing Tree
Traversals</a></li>
<li><a
href="5.7-information-flow-in-recursive-functions.html#information-flow-in-recursive-functions"
id="toc-information-flow-in-recursive-functions"><span
class="toc-section-number">5.7</span> Information Flow in Recursive
Functions</a></li>
<li><a
href="5.8-binary-tree-space-requirements-optional.html#binary-tree-space-requirements-optional"
id="toc-binary-tree-space-requirements-optional"><span
class="toc-section-number">5.8</span> Binary Tree Space Requirements
(optional)</a></li>
<li><a
href="5.9-multiple-binary-trees-optional.html#multiple-binary-trees-optional"
id="toc-multiple-binary-trees-optional"><span
class="toc-section-number">5.9</span> Multiple Binary Trees
(optional)</a></li>
<li><a
href="5.10-a-hard-information-flow-problem-optional.html#a-hard-information-flow-problem-optional"
id="toc-a-hard-information-flow-problem-optional"><span
class="toc-section-number">5.10</span> A Hard Information Flow Problem
(optional)</a></li>
<li><a
href="5.11-binary-tree-chapter-summary.html#binary-tree-chapter-summary"
id="toc-binary-tree-chapter-summary"><span
class="toc-section-number">5.11</span> Binary Tree Chapter
Summary</a></li>
<li><a href="5.12-general-trees-optional.html#general-trees-optional"
id="toc-general-trees-optional"><span
class="toc-section-number">5.12</span> General Trees (optional)</a></li>
<li><a
href="5.13-the-unionfind-algorithm-optional.html#the-unionfind-algorithm-optional"
id="toc-the-unionfind-algorithm-optional"><span
class="toc-section-number">5.13</span> The Union/Find Algorithm
(optional)</a></li>
<li><a
href="5.14-sequential-tree-representations-optional.html#sequential-tree-representations-optional"
id="toc-sequential-tree-representations-optional"><span
class="toc-section-number">5.14</span> Sequential Tree Representations
(optional)</a></li>
</ul></li>
<li><a href="6-binary-search-trees.html#binary-search-trees"
id="toc-binary-search-trees"><span class="toc-section-number">6</span>
Binary Search Trees</a>
<ul>
<li><a
href="6.1-binary-search-tree-definition.html#binary-search-tree-definition"
id="toc-binary-search-tree-definition"><span
class="toc-section-number">6.1</span> Binary Search Tree
Definition</a></li>
<li><a
href="6.2-binary-tree-guided-information-flow.html#binary-tree-guided-information-flow"
id="toc-binary-tree-guided-information-flow"><span
class="toc-section-number">6.2</span> Binary Tree Guided Information
Flow</a></li>
<li><a href="6.3-balanced-trees.html#balanced-trees"
id="toc-balanced-trees"><span class="toc-section-number">6.3</span>
Balanced Trees</a></li>
<li><a href="6.4-the-avl-tree.html#the-avl-tree"
id="toc-the-avl-tree"><span class="toc-section-number">6.4</span> The
AVL Tree</a></li>
<li><a href="6.5-red-black-tree.html#red-black-tree"
id="toc-red-black-tree"><span class="toc-section-number">6.5</span> The
Red-Black Tree (WORK IN PROGRESS)</a></li>
<li><a href="6.6-the-splay-tree-optional.html#the-splay-tree-optional"
id="toc-the-splay-tree-optional"><span
class="toc-section-number">6.6</span> The Splay Tree (optional)</a></li>
<li><a href="6.7-skip-lists-optional.html#skip-lists-optional"
id="toc-skip-lists-optional"><span class="toc-section-number">6.7</span>
Skip Lists (optional)</a></li>
<li><a
href="6.8-binary-search-tree-chapter-summary.html#binary-search-tree-chapter-summary"
id="toc-binary-search-tree-chapter-summary"><span
class="toc-section-number">6.8</span> Binary Search Tree Chapter
Summary</a></li>
</ul></li>
<li><a href="7-priority-queues.html#priority-queues"
id="toc-priority-queues"><span class="toc-section-number">7</span>
Priority queues</a>
<ul>
<li><a
href="7.1-array-implementation-for-complete-binary-trees.html#array-implementation-for-complete-binary-trees"
id="toc-array-implementation-for-complete-binary-trees"><span
class="toc-section-number">7.1</span> Array Implementation for Complete
Binary Trees</a></li>
<li><a
href="7.2-heaps-and-priority-queues.html#heaps-and-priority-queues"
id="toc-heaps-and-priority-queues"><span
class="toc-section-number">7.2</span> Heaps and Priority Queues</a></li>
<li><a href="7.3-heapsort.html#heapsort" id="toc-heapsort"><span
class="toc-section-number">7.3</span> Heapsort</a></li>
<li><a
href="7.4-huffman-coding-trees-optional.html#huffman-coding-trees-optional"
id="toc-huffman-coding-trees-optional"><span
class="toc-section-number">7.4</span> Huffman Coding Trees
(optional)</a></li>
<li><a
href="7.5-priority-queues-chapter-summary.html#priority-queues-chapter-summary"
id="toc-priority-queues-chapter-summary"><span
class="toc-section-number">7.5</span> Priority Queues Chapter
Summary</a></li>
</ul></li>
<li><a href="8-hashing.html#hashing" id="toc-hashing"><span
class="toc-section-number">8</span> Hashing</a>
<ul>
<li><a href="8.1-hash-function-principles.html#hash-function-principles"
id="toc-hash-function-principles"><span
class="toc-section-number">8.1</span> Hash Function Principles</a></li>
<li><a href="8.2-sample-hash-functions.html#sample-hash-functions"
id="toc-sample-hash-functions"><span
class="toc-section-number">8.2</span> Sample Hash Functions</a></li>
<li><a href="8.3-separate-chaining.html#separate-chaining"
id="toc-separate-chaining"><span class="toc-section-number">8.3</span>
Separate Chaining, or Open Hashing</a></li>
<li><a
href="8.4-converting-objects-to-table-indices.html#converting-objects-to-table-indices"
id="toc-converting-objects-to-table-indices"><span
class="toc-section-number">8.4</span> Converting Objects to Table
Indices</a></li>
<li><a href="8.5-bucket-hashing-optional.html#bucket-hashing-optional"
id="toc-bucket-hashing-optional"><span
class="toc-section-number">8.5</span> Bucket Hashing (optional)</a></li>
<li><a href="8.6-open-addressing.html#open-addressing"
id="toc-open-addressing"><span class="toc-section-number">8.6</span>
Open Addressing</a></li>
<li><a
href="8.7-improved-collision-resolution.html#improved-collision-resolution"
id="toc-improved-collision-resolution"><span
class="toc-section-number">8.7</span> Improved Collision
Resolution</a></li>
<li><a
href="8.8-analysis-of-open-addressing.html#analysis-of-open-addressing"
id="toc-analysis-of-open-addressing"><span
class="toc-section-number">8.8</span> Analysis of Open
Addressing</a></li>
<li><a href="8.9-open-addressing-deletion.html#open-addressing-deletion"
id="toc-open-addressing-deletion"><span
class="toc-section-number">8.9</span> Open Addressing, Deletion</a></li>
<li><a
href="8.10-hash-tables-in-real-life-optional.html#hash-tables-in-real-life-optional"
id="toc-hash-tables-in-real-life-optional"><span
class="toc-section-number">8.10</span> Hash Tables in Real Life
(optional)</a></li>
<li><a
href="8.11-hashing-chapter-summary-exercises.html#hashing-chapter-summary-exercises"
id="toc-hashing-chapter-summary-exercises"><span
class="toc-section-number">8.11</span> Hashing Chapter Summary
Exercises</a></li>
</ul></li>
<li><a href="9-graphs-1.html#graphs-1" id="toc-graphs-1"><span
class="toc-section-number">9</span> Graphs</a>
<ul>
<li><a href="9.1-graph-implementations.html#graph-implementations"
id="toc-graph-implementations"><span
class="toc-section-number">9.1</span> Graph Implementations</a></li>
<li><a href="9.2-graph-traversals.html#graph-traversals"
id="toc-graph-traversals"><span class="toc-section-number">9.2</span>
Graph Traversals</a></li>
<li><a href="9.3-topological-sort.html#topological-sort"
id="toc-topological-sort"><span class="toc-section-number">9.3</span>
Topological Sort</a></li>
<li><a href="9.4-shortest-paths-problems.html#shortest-paths-problems"
id="toc-shortest-paths-problems"><span
class="toc-section-number">9.4</span> Shortest-Paths Problems</a></li>
<li><a
href="9.5-minimal-cost-spanning-trees.html#minimal-cost-spanning-trees"
id="toc-minimal-cost-spanning-trees"><span
class="toc-section-number">9.5</span> Minimal Cost Spanning
Trees</a></li>
<li><a
href="9.6-all-pairs-shortest-paths-optional.html#all-pairs-shortest-paths-optional"
id="toc-all-pairs-shortest-paths-optional"><span
class="toc-section-number">9.6</span> All-Pairs Shortest Paths
(optional)</a></li>
<li><a href="9.7-graph-concepts-summary.html#graph-concepts-summary"
id="toc-graph-concepts-summary"><span
class="toc-section-number">9.7</span> Graph Concepts Summary</a></li>
</ul></li>
<li><a href="10-glossary.html#glossary" id="toc-glossary"><span
class="toc-section-number">10</span> Glossary</a></li>
<li><a href="11-bibliography.html#bibliography"
id="toc-bibliography"><span class="toc-section-number">11</span>
Bibliography</a></li>
</ul>
</div></nav></div>
<div class="col-9"><section id="heaps-and-priority-queues" class="level2"
data-number="7.2">
<h2 data-number="7.2"><span class="header-section-number">7.2</span>
Heaps and Priority Queues</h2>
<p>There are many situations, both in real life and in computing
applications, where we wish to choose the next “most important” from a
collection of people, tasks, or objects. For example, doctors in a
hospital emergency room often choose to see next the “most critical”
patient rather than the one who arrived first. When scheduling programs
for execution in a multitasking operating system, at any given moment
there might be several programs (usually called <a href="10-glossary.html#job" class="term">jobs</a>) ready to run. The next job selected is the one
with the highest <a href="10-glossary.html#priority" class="term">priority</a>. Priority is
indicated by a particular value associated with the job (and might
change while the job remains in the wait list).</p>
<p>When a collection of objects is organized by importance or priority,
we call this a <a href="10-glossary.html#priority-queue" class="term">priority queue</a>. A normal queue
data structure will not implement a priority queue efficiently because
search for the element with highest priority will take
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math>
time. A list, whether sorted or not, will also require
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math>
time for either insertion or removal. A BST that organizes records by
priority could be used, with the total of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
inserts and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
remove operations requiring
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n \log n)</annotation></semantics></math>
time in the average case. However, there is always the possibility that
the BST will become unbalanced, leading to bad performance. Instead, we
would like to find a data structure that is guaranteed to have good
performance for this special application.</p>
<p>This section presents the <a href="10-glossary.html#heap" class="term">heap</a><a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> data structure. A heap is defined by
two properties. First, it is a complete binary tree, so heaps are nearly
always implemented using the <a
href="7.1-array-implementation-for-complete-binary-trees.html#array-implementation-for-complete-binary-trees">array
representation for complete binary trees</a>. Second, the values stored
in a heap are <a href="10-glossary.html#partial-order" class="term">partially
ordered</a>. This means that there is a relationship between the value
stored at any node and the values of its children. There are two
variants of the heap, depending on the definition of this
relationship.</p>
<p>A <a href="10-glossary.html#max-heap" class="term">max heap</a> has the property that every node
stores a value that is <em>greater</em> than or equal to the value of
either of its children. Because the root has a value greater than or
equal to its children, which in turn have values greater than or equal
to their children, the root stores the maximum of all values in the
tree.</p>
<p>A <a href="10-glossary.html#min-heap" class="term">min heap</a> has the property that every node
stores a value that is <em>less</em> than or equal to that of its
children. Because the root has a value less than or equal to its
children, which in turn have values less than or equal to their
children, the root stores the minimum of all values in the tree.</p>
<p>Note that there is no necessary relationship between the value of a
node and that of its sibling in either the min heap or the max heap. For
example, it is possible that the values for all nodes in the left
subtree of the root are greater than the values for every node of the
right subtree. We can contrast BSTs and heaps by the strength of their
ordering relationships. A BST defines a <a href="10-glossary.html#total-order" class="term">total
order</a> on its nodes in that, given the positions for any two nodes
in the tree, the one to the “left” (equivalently, the one appearing
earlier in an inorder traversal) has a smaller key value than the one to
the “right”. In contrast, a heap implements a partial order. Given their
positions, we can determine the relative order for the key values of two
nodes in the heap <em>only</em> if one is a descendant of the other.</p>
<p>Min heaps and max heaps both have their uses. For example, the
Heapsort uses the max heap, while the Replacement Selection algorithm
used for external sorting uses a min heap. The examples in the rest of
this section will sometimes use a min and sometimes a max heap.</p>
<p>Be sure not to confuse the logical representation of a heap with its
physical implementation by means of the array-based complete binary
tree. The two are not synonymous because the logical view of the heap is
actually a tree structure, while the typical physical implementation
uses an array.</p>
<p>Here is an implementation for min heaps. The class uses records that
support the Comparable interface to provide flexibility.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MinHeap(PriorityQueue):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>     <span class="co"># The heap array.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     <span class="co"># Note that we use Python&#39;s internal lists, which are dynamic,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>     <span class="co"># so we don&#39;t have to implement resizing.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    _heap : <span class="bu">list</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Constructor supporting preloading of heap contents</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, h <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> h <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._heap <span class="op">=</span> []</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._heap <span class="op">=</span> <span class="bu">list</span>(h) <span class="co"># Make a copy of h</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._buildHeap()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> isEmpty(<span class="va">self</span>):</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Return true if there are no elements.&quot;&quot;&quot;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.size() <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> size(<span class="va">self</span>):</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Return current size of the heap.&quot;&quot;&quot;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>._heap)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> getMin(<span class="va">self</span>):</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Return smallest item into heap.&quot;&quot;&quot;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.size() <span class="op">==</span> <span class="dv">0</span>: <span class="cf">raise</span> <span class="pp">IndexError</span>(<span class="st">&quot;getMin from empty heap&quot;</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._heap[<span class="dv">0</span>]</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add(<span class="va">self</span>, elem):</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Insert elem into heap.&quot;&quot;&quot;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._heap.append(elem)            <span class="co"># New item starts at end of heap.</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._siftUp(<span class="bu">len</span>(<span class="va">self</span>._heap) <span class="op">-</span> <span class="dv">1</span>)  <span class="co"># Put the new value in its correct place.</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> removeMin(<span class="va">self</span>):</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Remove and return minimum value.&quot;&quot;&quot;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>._heap) <span class="op">==</span> <span class="dv">0</span>: <span class="cf">raise</span> <span class="pp">IndexError</span>(<span class="st">&quot;removeMin from empty heap&quot;</span>)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        removed <span class="op">=</span> <span class="va">self</span>._heap[<span class="dv">0</span>]</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>        last <span class="op">=</span> <span class="va">self</span>._heap.pop()     <span class="co"># Find and remove last element</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>._heap) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._heap[<span class="dv">0</span>] <span class="op">=</span> last    <span class="co"># Replace root with last element</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._siftDown(<span class="dv">0</span>)       <span class="co"># Put the new root in its correct place.</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> removed</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">str</span>(<span class="va">self</span>._heap)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">repr</span>(<span class="va">self</span>._heap)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__iter__</span>(<span class="va">self</span>):</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">iter</span>(<span class="va">self</span>._heap)</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Private helper methods</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="co"># /* *** ODSATag: invariant *** */</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _checkInvariant(<span class="va">self</span>):</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Check that the invariant holds.&quot;&quot;&quot;</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>        heapSize <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>._heap)</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(heapSize):</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>            left <span class="op">=</span> <span class="va">self</span>._getLeftChild(i)</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>            right <span class="op">=</span> <span class="va">self</span>._getRightChild(i)</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> left <span class="op">&lt;</span> heapSize <span class="kw">and</span> <span class="va">self</span>._lessThan(left, i):</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">AssertionError</span>(<span class="st">&quot;Parent (&quot;</span> <span class="op">+</span> i <span class="op">+</span> <span class="st">&quot;) is smaller than its left child: &quot;</span> <span class="op">+</span> <span class="va">self</span>._heap[i] <span class="op">+</span> <span class="st">&quot; &lt; &quot;</span> <span class="op">+</span> <span class="va">self</span>._heap[left])<span class="op">;</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> right <span class="op">&lt;</span> heapSize <span class="kw">and</span> <span class="va">self</span>._lessThan(right, i):</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">AssertionError</span>(<span class="st">&quot;Parent (&quot;</span> <span class="op">+</span> i <span class="op">+</span> <span class="st">&quot;) is smaller than its right child: &quot;</span> <span class="op">+</span> <span class="va">self</span>._heap[i] <span class="op">+</span> <span class="st">&quot; &lt; &quot;</span> <span class="op">+</span> <span class="va">self</span>._heap[right])<span class="op">;</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a><span class="co"># /* *** ODSAendTag: invariant *** */</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _isLeaf(<span class="va">self</span>, pos):</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Return true if pos is a leaf position, false otherwise.&quot;&quot;&quot;</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pos <span class="op">&gt;=</span> <span class="bu">len</span>(<span class="va">self</span>._heap) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _getLeftChild(<span class="va">self</span>, pos):</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Return the position for the left child of the given node.&quot;&quot;&quot;</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span>pos<span class="op">+</span><span class="dv">1</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _getRightChild(<span class="va">self</span>, pos):</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Return the position for the right child of the given node.&quot;&quot;&quot;</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span>pos<span class="op">+</span><span class="dv">2</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _getParent(<span class="va">self</span>, pos):</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Return the position for the parent. Returns 0 if we&#39;re already at the root.&quot;&quot;&quot;</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (pos<span class="op">-</span><span class="dv">1</span>) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _swap(<span class="va">self</span>, pos1, pos2):</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Swap the values in two positions.&quot;&quot;&quot;</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._heap[pos1], <span class="va">self</span>._heap[pos2] <span class="op">=</span> <span class="va">self</span>._heap[pos2], <span class="va">self</span>._heap[pos1]</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _buildHeap(<span class="va">self</span>):</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Heapify the contents of an array.&quot;&quot;&quot;</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>        heapSize <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>._heap)</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Loop from heapSize/2-1 down to 0</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pos <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(heapSize<span class="op">//</span><span class="dv">2</span>)):</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._siftDown(pos)</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _siftDown(<span class="va">self</span>, pos):</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Sift a value down the tree, return its new position.&quot;&quot;&quot;</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>        heapSize <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>._heap)</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="kw">not</span> <span class="va">self</span>._isLeaf(pos):</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>            child <span class="op">=</span> <span class="va">self</span>._getLeftChild(pos)</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>            right <span class="op">=</span> child <span class="op">+</span> <span class="dv">1</span>   <span class="co"># or: self._getRightChild(pos)</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> right <span class="op">&lt;</span> heapSize <span class="kw">and</span> <span class="va">self</span>._lessThan(right, child):</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>                child <span class="op">=</span> right   <span class="co"># &#39;child&#39; is now the index of the child with smaller value</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>._lessThan(child, pos):</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> pos</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._swap(pos, child)</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">=</span> child   <span class="co"># Move down one level in the tree.</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pos</span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _siftUp(<span class="va">self</span>, pos):</span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Sift a value up the tree, return its new position.&quot;&quot;&quot;</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> pos <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>            parent <span class="op">=</span> <span class="va">self</span>._getParent(pos)</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>._lessThan(pos, parent):</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> pos</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._swap(pos, parent)</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">=</span> parent   <span class="co"># Move up one level in the tree.</span></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pos</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _lessThan(<span class="va">self</span>, i, j):</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compare the values in the given positions.</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._heap[i] <span class="op">&lt;</span> <span class="va">self</span>._heap[j]</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Min-heap implementation</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MinHeap<span class="op">&lt;</span>E <span class="kw">extends</span> <span class="bu">Comparable</span><span class="op">&lt;</span>E<span class="op">&gt;&gt;</span> <span class="kw">implements</span> <span class="bu">PriorityQueue</span><span class="op">&lt;</span>E<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> E<span class="op">[]</span> heap<span class="op">;</span>       <span class="co">// The heap array</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> heapSize<span class="op">;</span>   <span class="co">// Size of heap, and index of the next free slot</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">static</span> <span class="dt">int</span> MinCapacity <span class="op">=</span> <span class="dv">8</span><span class="op">;</span>               <span class="co">// Minimum capacity of heap</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">static</span> <span class="dt">double</span> MinLoadFactor <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span>        <span class="co">// Must be smaller than 1/CapacityMultiplier</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">static</span> <span class="dt">double</span> CapacityMultiplier <span class="op">=</span> <span class="fl">1.5</span><span class="op">;</span>   <span class="co">// Factor to grow/shrink the capacity</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Constructor supporting preloading of heap contents</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">@SuppressWarnings</span><span class="op">(</span><span class="st">&quot;unchecked&quot;</span><span class="op">)</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">MinHeap</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        heap <span class="op">=</span> <span class="op">(</span>E<span class="op">[])</span> <span class="kw">new</span> <span class="bu">Comparable</span><span class="op">[</span>MinCapacity<span class="op">];</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        heapSize <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">MinHeap</span><span class="op">(</span>E<span class="op">[]</span> h<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        heap <span class="op">=</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">copyOf</span><span class="op">(</span>h<span class="op">,</span> h<span class="op">.</span><span class="fu">length</span><span class="op">);</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        heapSize <span class="op">=</span> heap<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="fu">buildHeap</span><span class="op">();</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>heapSize <span class="op">&lt;</span> MinCapacity<span class="op">)</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>            <span class="fu">resizeHeap</span><span class="op">(</span>MinCapacity<span class="op">);</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return true if there are no elements.</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">isEmpty</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> heapSize <span class="op">==</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return current size of the heap</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">size</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> heapSize<span class="op">;</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> E <span class="fu">getMin</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!(</span>heapSize <span class="op">&gt;</span> <span class="dv">0</span><span class="op">))</span> <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">NoSuchElementException</span><span class="op">(</span><span class="st">&quot;getMin from empty heap&quot;</span><span class="op">);</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> heap<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Insert val into heap</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">add</span><span class="op">(</span>E elem<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>heapSize <span class="op">&gt;=</span> heap<span class="op">.</span><span class="fu">length</span><span class="op">)</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>            <span class="fu">resizeHeap</span><span class="op">((</span><span class="dt">int</span><span class="op">)</span> <span class="op">(</span>heap<span class="op">.</span><span class="fu">length</span> <span class="op">*</span> CapacityMultiplier<span class="op">));</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        heap<span class="op">[</span>heapSize<span class="op">]</span> <span class="op">=</span> elem<span class="op">;</span>  <span class="co">// Start at end of heap.</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        <span class="fu">siftUp</span><span class="op">(</span>heapSize<span class="op">);</span>       <span class="co">// Put the new value in its correct place.</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        heapSize<span class="op">++;</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Remove and return minimum value</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> E <span class="fu">removeMin</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!(</span>heapSize <span class="op">&gt;</span> <span class="dv">0</span><span class="op">))</span> <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">NoSuchElementException</span><span class="op">(</span><span class="st">&quot;removeMin from empty heap&quot;</span><span class="op">);</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>        E removed <span class="op">=</span> heap<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>        heapSize<span class="op">--;</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>        <span class="fu">swap</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> heapSize<span class="op">);</span>  <span class="co">// Swap the root with the current last value.</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>heapSize <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> </span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>            <span class="fu">siftDown</span><span class="op">(</span><span class="dv">0</span><span class="op">);</span>    <span class="co">// Put the new heap root val in its correct place.</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>heapSize <span class="op">&lt;=</span> heap<span class="op">.</span><span class="fu">length</span> <span class="op">*</span> MinLoadFactor<span class="op">)</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>            <span class="fu">resizeHeap</span><span class="op">((</span><span class="dt">int</span><span class="op">)</span> <span class="op">(</span>heap<span class="op">.</span><span class="fu">length</span> <span class="op">/</span> CapacityMultiplier<span class="op">));</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>        heap<span class="op">[</span>heapSize<span class="op">]</span> <span class="op">=</span> <span class="kw">null</span><span class="op">;</span>   <span class="co">// Remove the old root value, for garbage collection.</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> removed<span class="op">;</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="bu">String</span> <span class="fu">toString</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">toString</span><span class="op">(</span>heap<span class="op">).</span><span class="fu">replace</span><span class="op">(</span><span class="st">&quot;null&quot;</span><span class="op">,</span> <span class="st">&quot;-&quot;</span><span class="op">)</span> <span class="op">+</span> heapSize<span class="op">;</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="bu">Iterator</span><span class="op">&lt;</span>E<span class="op">&gt;</span> <span class="fu">iterator</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>    <span class="co">////////////////////////////////////////////////////////////////////////////////</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Private helper methods</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a><span class="co">/* *** ODSATag: invariant *** */</span></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check that the invariant holds.</span></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">checkInvariant</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> heapSize<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> left <span class="op">=</span> <span class="fu">getLeftChild</span><span class="op">(</span>i<span class="op">);</span></span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> right <span class="op">=</span> <span class="fu">getRightChild</span><span class="op">(</span>i<span class="op">);</span></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>left <span class="op">&lt;</span> heapSize <span class="op">&amp;&amp;</span> <span class="fu">lessThan</span><span class="op">(</span>left<span class="op">,</span> i<span class="op">))</span></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>                <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">AssertionError</span><span class="op">(</span><span class="st">&quot;Parent (&quot;</span> <span class="op">+</span> i <span class="op">+</span> <span class="st">&quot;) is smaller than its left child: &quot;</span> <span class="op">+</span> heap<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> <span class="st">&quot; &lt; &quot;</span> <span class="op">+</span> heap<span class="op">[</span>left<span class="op">]);</span></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>right <span class="op">&lt;</span> heapSize <span class="op">&amp;&amp;</span> <span class="fu">lessThan</span><span class="op">(</span>right<span class="op">,</span> i<span class="op">))</span></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>                <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">AssertionError</span><span class="op">(</span><span class="st">&quot;Parent (&quot;</span> <span class="op">+</span> i <span class="op">+</span> <span class="st">&quot;) is smaller than its right child: &quot;</span> <span class="op">+</span> heap<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> <span class="st">&quot; &lt; &quot;</span> <span class="op">+</span> heap<span class="op">[</span>right<span class="op">]);</span></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a><span class="co">/* *** ODSAendTag: invariant *** */</span></span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a><span class="co">/* *** ODSATag: resize *** */</span></span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">resizeHeap</span><span class="op">(</span><span class="dt">int</span> newCapacity<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>newCapacity <span class="op">&lt;</span> MinCapacity<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a>        <span class="at">@SuppressWarnings</span><span class="op">(</span><span class="st">&quot;unchecked&quot;</span><span class="op">)</span></span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>        E<span class="op">[]</span> newHeap <span class="op">=</span> <span class="op">(</span>E<span class="op">[])</span> <span class="kw">new</span> <span class="bu">Comparable</span><span class="op">[</span>newCapacity<span class="op">];</span></span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> heapSize<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>            newHeap<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> heap<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>        heap <span class="op">=</span> newHeap<span class="op">;</span></span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a><span class="co">/* *** ODSAendTag: resize *** */</span></span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return true if pos is a leaf position, false otherwise.</span></span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">boolean</span> <span class="fu">isLeaf</span><span class="op">(</span><span class="dt">int</span> pos<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pos <span class="op">&gt;=</span> heapSize <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return the position for the left child of the given node</span></span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">getLeftChild</span><span class="op">(</span><span class="dt">int</span> pos<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-106"><a href="#cb2-106" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> pos <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-107"><a href="#cb2-107" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-108"><a href="#cb2-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-109"><a href="#cb2-109" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return the position for the right child of the given node</span></span>
<span id="cb2-110"><a href="#cb2-110" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">getRightChild</span><span class="op">(</span><span class="dt">int</span> pos<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-111"><a href="#cb2-111" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> pos <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb2-112"><a href="#cb2-112" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-113"><a href="#cb2-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-114"><a href="#cb2-114" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return the position for the parent. Returns 0 if we&#39;re already at the root.</span></span>
<span id="cb2-115"><a href="#cb2-115" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">getParent</span><span class="op">(</span><span class="dt">int</span> pos<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-116"><a href="#cb2-116" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>pos <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb2-117"><a href="#cb2-117" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-118"><a href="#cb2-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-119"><a href="#cb2-119" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Swap the values in two positions</span></span>
<span id="cb2-120"><a href="#cb2-120" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">swap</span><span class="op">(</span><span class="dt">int</span> pos1<span class="op">,</span> <span class="dt">int</span> pos2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-121"><a href="#cb2-121" aria-hidden="true" tabindex="-1"></a>        E tmp <span class="op">=</span> heap<span class="op">[</span>pos1<span class="op">];</span></span>
<span id="cb2-122"><a href="#cb2-122" aria-hidden="true" tabindex="-1"></a>        heap<span class="op">[</span>pos1<span class="op">]</span> <span class="op">=</span> heap<span class="op">[</span>pos2<span class="op">];</span></span>
<span id="cb2-123"><a href="#cb2-123" aria-hidden="true" tabindex="-1"></a>        heap<span class="op">[</span>pos2<span class="op">]</span> <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb2-124"><a href="#cb2-124" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-125"><a href="#cb2-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-126"><a href="#cb2-126" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Heapify the contents of an array</span></span>
<span id="cb2-127"><a href="#cb2-127" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">buildHeap</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-128"><a href="#cb2-128" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> pos <span class="op">=</span> heapSize<span class="op">/</span><span class="dv">2</span><span class="op">-</span><span class="dv">1</span><span class="op">;</span> pos <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> pos<span class="op">--)</span></span>
<span id="cb2-129"><a href="#cb2-129" aria-hidden="true" tabindex="-1"></a>            <span class="fu">siftDown</span><span class="op">(</span>pos<span class="op">);</span></span>
<span id="cb2-130"><a href="#cb2-130" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-131"><a href="#cb2-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-132"><a href="#cb2-132" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sift a value down the tree, return its new position.</span></span>
<span id="cb2-133"><a href="#cb2-133" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">siftDown</span><span class="op">(</span><span class="dt">int</span> pos<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-134"><a href="#cb2-134" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(!</span><span class="fu">isLeaf</span><span class="op">(</span>pos<span class="op">))</span> <span class="op">{</span></span>
<span id="cb2-135"><a href="#cb2-135" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> child <span class="op">=</span> <span class="fu">getLeftChild</span><span class="op">(</span>pos<span class="op">);</span></span>
<span id="cb2-136"><a href="#cb2-136" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> right <span class="op">=</span> child <span class="op">+</span> <span class="dv">1</span><span class="op">;</span>   <span class="co">// or: getRightChild(pos)</span></span>
<span id="cb2-137"><a href="#cb2-137" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>right <span class="op">&lt;</span> heapSize <span class="op">&amp;&amp;</span> <span class="fu">lessThan</span><span class="op">(</span>right<span class="op">,</span> child<span class="op">))</span></span>
<span id="cb2-138"><a href="#cb2-138" aria-hidden="true" tabindex="-1"></a>                child <span class="op">=</span> right<span class="op">;</span>   <span class="co">// &#39;child&#39; is now the index of the child with smaller value</span></span>
<span id="cb2-139"><a href="#cb2-139" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span><span class="fu">lessThan</span><span class="op">(</span>child<span class="op">,</span> pos<span class="op">))</span></span>
<span id="cb2-140"><a href="#cb2-140" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> pos<span class="op">;</span></span>
<span id="cb2-141"><a href="#cb2-141" aria-hidden="true" tabindex="-1"></a>            <span class="fu">swap</span><span class="op">(</span>pos<span class="op">,</span> child<span class="op">);</span></span>
<span id="cb2-142"><a href="#cb2-142" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">=</span> child<span class="op">;</span>   <span class="co">// Move down one level in the tree.</span></span>
<span id="cb2-143"><a href="#cb2-143" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-144"><a href="#cb2-144" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pos<span class="op">;</span></span>
<span id="cb2-145"><a href="#cb2-145" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-146"><a href="#cb2-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-147"><a href="#cb2-147" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sift a value up the tree, return its new position.</span></span>
<span id="cb2-148"><a href="#cb2-148" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">siftUp</span><span class="op">(</span><span class="dt">int</span> pos<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-149"><a href="#cb2-149" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>pos <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-150"><a href="#cb2-150" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> parent <span class="op">=</span> <span class="fu">getParent</span><span class="op">(</span>pos<span class="op">);</span></span>
<span id="cb2-151"><a href="#cb2-151" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span><span class="fu">lessThan</span><span class="op">(</span>pos<span class="op">,</span> parent<span class="op">))</span></span>
<span id="cb2-152"><a href="#cb2-152" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> pos<span class="op">;</span></span>
<span id="cb2-153"><a href="#cb2-153" aria-hidden="true" tabindex="-1"></a>            <span class="fu">swap</span><span class="op">(</span>pos<span class="op">,</span> parent<span class="op">);</span></span>
<span id="cb2-154"><a href="#cb2-154" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">=</span> parent<span class="op">;</span>   <span class="co">// Move up one level in the tree.</span></span>
<span id="cb2-155"><a href="#cb2-155" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-156"><a href="#cb2-156" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pos<span class="op">;</span></span>
<span id="cb2-157"><a href="#cb2-157" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-158"><a href="#cb2-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-159"><a href="#cb2-159" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compare the values in the given positions.</span></span>
<span id="cb2-160"><a href="#cb2-160" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">boolean</span> <span class="fu">lessThan</span><span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-161"><a href="#cb2-161" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> heap<span class="op">[</span>i<span class="op">].</span><span class="fu">compareTo</span><span class="op">(</span>heap<span class="op">[</span>j<span class="op">])</span> <span class="op">&lt;</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-162"><a href="#cb2-162" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-163"><a href="#cb2-163" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>This class definition makes two concessions to the fact that an
array-based implementation is used. First, heap nodes are indicated by
their logical position within the heap rather than by a pointer to the
node. In practice, the logical heap position corresponds to the
identically numbered physical position in the array. Second, the
constructor takes as input a pointer to the array to be used. This
approach provides the greatest flexibility for using the heap because
all data values can be loaded into the array directly by the client. The
advantage of this comes during the heap construction phase, as explained
below. The constructor also takes an integer parameter indicating the
initial size of the heap (based on the number of elements initially
loaded into the array) and a second integer parameter indicating the
maximum size allowed for the heap (the size of the array).</p>
</blockquote>
<p>The class contains some private auxiliary methods that are use when
adding and removing elements from the heap: <code>isLeaf(pos)</code>
returns <code>true</code> if position <code>pos</code> is a leaf in the
tree, and <code>false</code> otherwise. Members
<code>getLeftChild</code>, <code>getRightChild</code>, and
<code>getParent</code> return the position (actually, the array index)
for the left child, right child, and parent of the position passed,
respectively.</p>
<p>One way to build a heap is to insert the elements one at a time.
Method <code>add</code> will insert a new element
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
into the heap.</p>
<p>
<div id="heapinsertCON" class="ssAV" data-short-name="heapinsertCON" data-long-name="Heap insert Slideshow" alt="Heap insert Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<p>You might expect the heap insertion process to be similar to the
insert function for a BST, starting at the root and working down through
the heap. However, this approach is not likely to work because the heap
must maintain the shape of a complete binary tree. Equivalently, if the
heap takes up the first
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
positions of its array prior to the call to <code>add</code>, it must
take up the first
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math>
positions after. To accomplish this, <code>add</code> first places
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
at position
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
of the array. Of course,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
is unlikely to be in the correct position. To move
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
to the right place, it is compared to its parent’s value. If the value
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
is less than or equal to the value of its parent, then it is in the
correct place and the insert routine is finished. If the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
is greater than that of its parent, then the two elements swap
positions. From here, the process of comparing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
to its (current) parent continues until
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
reaches its correct position.</p>
<p>Since the heap is a complete binary tree, its height is guaranteed to
be the minimum possible. In particular, a heap containing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
nodes will have a height of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(\log n)</annotation></semantics></math>.
Intuitively, we can see that this must be true because each level that
we add will slightly more than double the number of nodes in the tree
(the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
th level has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>i</mi></msup><annotation encoding="application/x-tex">2^i</annotation></semantics></math>
nodes, and the sum of the first
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
levels is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{i+1}-1</annotation></semantics></math>).
Starting at 1, we can double only
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math>
times to reach a value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>.
To be precise, the height of a heap with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
nodes is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⌈</mo><mo>log</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \log n + 1 \rceil</annotation></semantics></math>.</p>
<p>Each call to <code>add</code> takes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(\log n)</annotation></semantics></math>
time in the worst case, because the value being inserted can move at
most the distance from the bottom of the tree to the top of the tree.
Thus, to insert
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
values into the heap, if we insert them one at a time, will take
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n \log n)</annotation></semantics></math>
time in the worst case.</p>
<p>
<div id="heapinsertPRO" class="embedContainer">
<iframe id="heapinsertPRO_iframe" aria-label="heapinsertPRO" src="../interactive/Binary/heapinsertPRO.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>
</p>
<div class="col-9"><section id="building-a-heap" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1"><span class="header-section-number">7.2.1</span>
Building a Heap</h3>
<p>If all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
values are available at the beginning of the building process, we can
build the heap faster than just inserting the values into the heap one
by one. Consider this example, with two possible ways to heapify an
initial set of values in an array.</p>
<div id="HeapBuild">
<p>
<div id="HeapBldChoiceCON" class="ssAV" data-short-name="HeapBldChoiceCON" data-long-name="Heap Build Choices" alt="Heap Build Choices" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<p>Two series of exchanges to build a max heap. (a) This heap is built
by a series of nine exchanges in the order (4-2), (4-1), (2-1), (5-2),
(5-4), (6-3), (6-5), (7-5), (7-6). (b) This heap is built by a series of
four exchanges in the order (5-2), (7-3), (7-1), (6-1).</p>
</div>
<p>From this example, it is clear that the heap for any given set of
numbers is not unique, and we see that some rearrangements of the input
values require fewer exchanges than others to build the heap. So, how do
we pick the best rearrangement?</p>
<p>One good algorithm stems from induction. Suppose that the left and
right subtrees of the root are already heaps, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
is the name of the element at the root. This situation is illustrated by
this figure:</p>
<div id="HeapInduct">
<p>
<div id="HeapsIndCON" class="ssAV" data-short-name="HeapsIndCON" data-long-name="Binary/HeapsIndCON" alt="Binary/HeapsIndCON" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<p>Final stage in the heap-building algorithm. Both subtrees of node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
are heaps. All that remains is to push
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
down to its proper level in the heap.</p>
</div>
<p>In this case there are two possibilities.</p>
<ol type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
has a value greater than or equal to its two children. In this case,
construction is complete.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
has a value less than one or both of its children.</li>
</ol>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
should be exchanged with the child that has greater value. The result
will be a heap, except that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
might still be less than one or both of its (new) children. In this
case, we simply continue the process of “pushing down”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
until it reaches a level where it is greater than its children, or is a
leaf node. This process is implemented by the private method
<code>siftDown</code>.</p>
<p>This approach assumes that the subtrees are already heaps, suggesting
that a complete algorithm can be obtained by visiting the nodes in some
order such that the children of a node are visited <em>before</em> the
node itself. One simple way to do this is simply to work from the high
index of the array to the low index. Actually, the build process need
not visit the leaf nodes (they can never move down because they are
already at the bottom), so the building algorithm can start in the
middle of the array, with the first internal node.</p>
<p>Here is a visualization of the heap build process.</p>
<p>
<div id="heapbuildCON" class="ssAV" data-short-name="heapbuildCON" data-long-name="Heapbuild Slideshow" alt="Heapbuild Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<p>Method <code>buildHeap</code> implements the building algorithm.</p>
<p>
<div id="heapbuildPRO" class="embedContainer">
<iframe id="heapbuildPRO_iframe" aria-label="heapbuildPRO" src="../interactive/Binary/heapbuildPRO.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>
</p>
<p>What is the cost of <code>buildHeap</code>? Clearly it is the sum of
the costs for the calls to <code>siftDown</code>. Each
<code>siftDown</code> operation can cost at most the number of levels it
takes for the node being sifted to reach the bottom of the tree. In any
complete tree, approximately half of the nodes are leaves and so cannot
be moved downward at all. One quarter of the nodes are one level above
the leaves, and so their elements can move down at most one level. At
each step up the tree we get half the number of nodes as were at the
previous level, and an additional height of one. The maximum sum of
total distances that elements can go is therefore</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mo>log</mo><mi>n</mi></mrow></munderover><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mfrac><mi>n</mi><msup><mn>2</mn><mi>i</mi></msup></mfrac></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mfrac><mi>n</mi><mn>2</mn></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mo>log</mo><mi>n</mi></mrow></munderover><mfrac><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray}
\sum_{i=1}^{\log n} (i-1)\frac{n}{2^i}
&amp;=&amp; \frac{n}{2}\sum_{i=1}^{\log n} \frac{i-1}{2^{i-1}}
\end{eqnarray}
</annotation></semantics></math></p>
<p>The summation on the right <a href="10-glossary.html#summation" class="term">is
known</a> to have a closed-form solution of approximately 2, so this
algorithm takes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math>
time in the worst case. This is far better than building the heap one
element at a time, which would cost
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n \log n)</annotation></semantics></math>
in the worst case. It is also faster than the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n \log n)</annotation></semantics></math>
average-case time and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n^2)</annotation></semantics></math>
worst-case time required to build the BST.</p>
<p>
<div id="heapbuildProofCON" class="ssAV" data-short-name="heapbuildProofCON" data-long-name="Heap build analysis proof Slideshow" alt="Heap build analysis proof Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
</section></div>
<section id="removing-from-the-heap-or-updating-an-objects-priority"
class="level3" data-number="7.2.2">
<h3 data-number="7.2.2"><span class="header-section-number">7.2.2</span>
Removing from the heap or updating an object’s priority</h3>
<p>
<div id="heapmaxCON" class="ssAV" data-short-name="heapmaxCON" data-long-name="Remove Max Slideshow" alt="Remove Max Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<p>Because the heap is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math>
levels deep, the cost of deleting the maximum element is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(\log n)</annotation></semantics></math>
in the average and worst cases.</p>
<p>
<div id="heapremovePRO" class="embedContainer">
<iframe id="heapremovePRO_iframe" aria-label="heapremovePRO" src="../interactive/Binary/heapremovePRO.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>
</p>
<div class="line-block"></div>
<p>
<div id="heapremoveCON" class="ssAV" data-short-name="heapremoveCON" data-long-name="Remove Any Slideshow" alt="Remove Any Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<blockquote>
<p>For some applications, objects might get their priority modified. One
solution in this case is to remove the object and reinsert it. To do
this, the application needs to know the position of the object in the
heap. Another option is to change the priority value of the object, and
then update its position in the heap. Note that a remove operation
implicitly has to do this anyway, since when the last element in the
heap is swapped with the one being removed, that value might be either
too small or too big for its new position. So we use a utility method
called <code>update</code> in both the <code>remove</code> and
<code>modify</code> methods to handle this process.</p>
</blockquote>
</section>
<section id="binary-heaps-as-priority-queues" class="level3"
data-number="7.2.3">
<h3 data-number="7.2.3"><span class="header-section-number">7.2.3</span>
Binary Heaps as Priority Queues</h3>
<p>The heap is a natural implementation for the priority queue discussed
at the beginning of this section. Jobs can be added to the heap (using
their priority value as the ordering key) when needed. Method
<code>removeMin</code> can be called whenever a new job is to be
executed.</p>
<p>Priority queues can be helpful for solving graph problems such as the
<a href="10-glossary.html#single-source-shortest-paths-problem" class="term">single-source shortest paths problem</a> and
finding the <a href="10-glossary.html#minimal-cost-spanning-tree" class="term">minimal-cost spanning tree</a>.</p>
<p>For a story about Priority Queues and dragons, see <a
href="http://computationaltales.blogspot.com/2011/04/stacks-queues-priority-queues-and.html">Computational
Fairy Tales: Stacks, Queues, Priority Queues, and the Prince’s Complaint
Line</a></p>
<section id="changing-the-priority-of-elements" class="level4"
data-number="7.2.3.1">
<h4 data-number="7.2.3.1"><span
class="header-section-number">7.2.3.1</span> Changing the priority of
elements</h4>
<p>Some applications of priority queues require the ability to change
the priority of an object already stored in the queue. This might
require that the object’s position in the heap representation be
updated. Unfortunately, a min heap is not efficient when searching for
an arbitrary value; it is only good for finding the minimum value.
However, if we already know the index for an object within the heap, it
is a simple matter to update its priority (including changing its
position to maintain the heap property) or remove it.</p>
<p>A typical implementation for priority queues requiring updating of
priorities will need to use an auxiliary data structure that supports
efficient search for objects (such as a BST). Records in the auxiliary
data structure will store the object’s heap index, so that the object’s
priority can be updated.</p>
</section>
<section id="practice-questions-4" class="level4" data-number="7.2.3.2">
<h4 data-number="7.2.3.2"><span
class="header-section-number">7.2.3.2</span> Practice Questions</h4>
<p>
<div id="HeapSumm" class="embedContainer">
<iframe id="HeapSumm_iframe" aria-label="HeapSumm" src="../interactive/Binary/HeapSumm.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>
</p>
</section>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Note that the term “heap” is also sometimes used to
refer to <a href="10-glossary.html#free-store" class="term">free store</a>.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<script type="text/javascript" src="../interactive/DataStructures/binaryheap.js"></script>
<script type="text/javascript" src="../interactive/Binary/heapinsertCON.js"></script>
<script type="text/javascript" src="../interactive/Binary/HeapBldChoiceCON.js"></script>
<script type="text/javascript" src="../interactive/Binary/HeapsIndCON.js"></script>
<script type="text/javascript" src="../interactive/Binary/heapbuildCON.js"></script>
<script type="text/javascript" src="../interactive/Binary/heapbuildProofCON.js"></script>
<script type="text/javascript" src="../interactive/Binary/heapmaxCON.js"></script>
<script type="text/javascript" src="../interactive/Binary/heapremoveCON.js"></script>
</div></body>
</html>
