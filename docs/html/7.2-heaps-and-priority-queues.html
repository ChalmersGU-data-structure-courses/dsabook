<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Cliff Shaffer" />
  <meta name="author" content="Peter Ljunglöf" />
  <meta name="author" content="Nick Smallbone" />
  <title>DSABook – Heaps and Priority Queues</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #204a87; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #204a87; font-weight: bold; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../css/main.css" />
  <link rel="stylesheet" href="../css/book.css" />
  <link rel="stylesheet" href="../css/quiz.css" />
  <link rel="stylesheet" href="../css/mobile.css" />
  
  <link rel="stylesheet" href="../lib/JSAV.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaMOD.css" type="text/css" />
  <link rel="stylesheet" href="../lib/jquery.ui.min.css" type="text/css" />
  <link rel="stylesheet" href="../lib/odsaStyle.css" type="text/css" />
  <link rel="stylesheet" href="../lib/ChalmersGU-interactive.css" type="text/css" />

  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
      },
      "HTML-CSS": {
        scale: "80",
      }
    });
  </script>

  <script type="text/javascript" src="../lib/jquery.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.migrate.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src="../lib/localforage.min.js"></script>
  <script type="text/javascript" src="../lib/accessibility.js"></script>
  <script type="text/javascript" src="../lib/jquery.ui.min.js"></script>
  <script type="text/javascript" src="../lib/jquery.transit.js"></script>
  <script type="text/javascript" src="../lib/raphael.js"></script>
  <script type="text/javascript" src="../lib/JSAV.js"></script>
  <script type="text/javascript" src="../lib/config.js"></script>
  <script type="text/javascript" src="../lib/timeme.js"></script>
  <script type="text/javascript" src="../lib/odsaUtils.js"></script>
  <script type="text/javascript" src="../lib/odsaMOD.js"></script>
  <script type="text/javascript" src="../lib/d3.min.js"></script>
  <script type="text/javascript" src="../lib/d3-selection-multi.v1.min.js"></script>
  <script type="text/javascript" src="../lib/dataStructures.js"></script>
  <script type="text/javascript" src="../lib/conceptMap.js"></script>

  <script>
    ODSA.SETTINGS.MODULE_SECTIONS = [
    'internal-variables', 
    'getting-and-setting-values', 
    'adding-elements', 
    'add-practice-exericse', 
    'removing-elements', 
    'remove-practice-exericise', 
    'static-array-based-list-summary-questions', 
    'static-array-based-list:-full-code',
    ];
    ODSA.SETTINGS.MODULE_NAME = "DSABook";
    ODSA.SETTINGS.MODULE_LONG_NAME = "Data Structures and Algorithms";
    JSAV_OPTIONS['lang']='en';
    JSAV_EXERCISE_OPTIONS['code']='pseudo';
  </script>

  
  <script type="text/javascript" src="../scripts/quizhandler.js"></script>
<link href="../interactive/Binary/HeapBldChoiceCON.css" rel="stylesheet" type="text/css"/>
<link href="../interactive/Binary/HeapsIndCON.css" rel="stylesheet" type="text/css"/>
<link href="../interactive/Binary/heapbuildProofCON.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav id="sitenav">
<div class="sitenav">
<span class="navlink">
<span class="navlink-label">Up:</span> <a href="7-priority-queues.html" accesskey="u" rel="up">Priority queues</a>
</span>
<span class="navlink">
<span class="navlink-label">Top:</span> <a href="index.html" accesskey="t" rel="top">Data Structures and Algorithms</a>
</span>
</div>
<div class="sitenav">
<span class="navlink">
<span class="navlink-label">Previous:</span> <a href="7.1-array-representation-for-complete-binary-trees.html" accesskey="p" rel="previous">Array Representation for Complete Binary Trees</a>
</span>
<span class="navlink">
<span class="navlink-label">Next:</span> <a href="7.3-heapsort.html" accesskey="n" rel="next">Heapsort</a>
</span>
</div>
</nav>
<section id="heaps-and-priority-queues" class="level2"
data-number="7.2">
<h2 data-number="7.2"><span class="header-section-number">7.2</span>
Heaps and Priority Queues</h2>
<p>There are many situations, both in real life and in computing
applications, where we wish to choose the next “most important” from a
collection of people, tasks, or objects. For example, doctors in a
hospital emergency room often choose to see next the “most critical”
patient rather than the one who arrived first. When scheduling programs
for execution in a multitasking operating system, at any given moment
there might be several programs (usually called <a
href="10-glossary.html#job" class="term"
title="Common name for processes or tasks to be run by an operating system. They typically need to be processed in order of importance, and so are kept organized by a priority queue. Another common use for this term is for a collection of tasks to be ordered by a topological sort.">jobs</a>)
ready to run. The next job selected is the one with the highest <a
href="10-glossary.html#priority" class="term"
title="A quantity assigned to each of a collection of jobs or tasks that indicate importance for order of processing. For example, in an operating system, there could be a collection of processes (jobs) ready to run. The operating system must select the next task to execute, based on their priorities.">priority</a>.
Priority is indicated by a particular value associated with the job (and
might change while the job remains in the wait list).</p>
<p>When a collection of objects is organized by importance or priority,
we call this a <a href="10-glossary.html#priority-queue" class="term"
title="An ADT whose primary operations of insert of records, and deletion of the greatest (or, in an alternative implementation, the least) valued record. Most often implemented using the heap data structure. The name comes from a common application where the records being stored represent tasks, with the ordering values based on the priorities of the tasks.">priority
queue</a>. A normal queue data structure will not implement a priority
queue efficiently because search for the element with highest priority
will take
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math>
time. A list, whether sorted or not, will also require
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math>
time for either insertion or removal. A BST that organizes records by
priority could be used, with the total of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
inserts and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
remove operations requiring
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n \log n)</annotation></semantics></math>
time in the average case. However, there is always the possibility that
the BST will become unbalanced, leading to bad performance. Instead, we
would like to find a data structure that is guaranteed to have good
performance for this special application.</p>
<p>This section presents the <a href="10-glossary.html#binary-heap"
class="term"
title="The head data structure is a complete binary tree with the requirement that every node has a value greater than its children (called a max heap), or else the requirement that every node has a value less than its children (called a min heap). Since it is a complete binary tree, a heap is nearly always implemented using an array rather than an explicit tree structure. To add a new value to a heap, or to remove the extreme value (the max value in a max-heap or min value in a min-heap) and update the heap, takes $\Theta(\log n)$ time in the worst case. However, if given all of the values in an unordered array, the values can be re-arranged to form a heap in only $\Theta(n)$ time. Due to its space and time efficiency, the heap is a popular choice for implementing a priority queue. Uncommonly, *heap* is a synonym for free store.">binary
heap</a> data structure. A heap is defined by two properties. First, it
is a complete binary tree, so heaps are nearly always implemented using
the <a
href="7.1-array-representation-for-complete-binary-trees.html#array-representation-for-complete-binary-trees">array
representation for complete binary trees</a>. Second, the values stored
in a heap are <a href="10-glossary.html#partial-order" class="term"
title="In set notation, a binary relation is called a partial order if it is antisymmetric and transitive. If the relation is also reflexive, then it is a non-strict partial order. Alternatively, if the relation is also irreflexive, then it is a strict partial order.">partially
ordered</a>. This means that there is a relationship between the value
stored at any node and the values of its children. There are two
variants of the heap, depending on the definition of this
relationship.</p>
<p>A <a href="10-glossary.html#max-heap" class="term"
title="A heap where every node has a key value greater than its children. As a consequence, the node with maximum key value is at the root.">max
heap</a> has the property that every node stores a value that is
<em>greater</em> than or equal to the value of either of its children.
Because the root has a value greater than or equal to its children,
which in turn have values greater than or equal to their children, the
root stores the maximum of all values in the tree.</p>
<p>A <a href="10-glossary.html#min-heap" class="term"
title="A heap where every node has a key value less than its children. As a consequence, the node with minimum key value is at the root.">min
heap</a> has the property that every node stores a value that is
<em>less</em> than or equal to that of its children. Because the root
has a value less than or equal to its children, which in turn have
values less than or equal to their children, the root stores the minimum
of all values in the tree.</p>
<p>Note that there is no necessary relationship between the value of a
node and that of its sibling in either the min heap or the max heap. For
example, it is possible that the values for all nodes in the left
subtree of the root are greater than the values for every node of the
right subtree. We can contrast BSTs and heaps by the strength of their
ordering relationships. A BST defines a <a
href="10-glossary.html#total-order" class="term"
title="A binary relation on a set where every pair of distinct elements in the set are comparable (that is, one can determine which of the two is greater than the other).">total
order</a> on its nodes in that, given the positions for any two nodes in
the tree, the one to the “left” (equivalently, the one appearing earlier
in an inorder traversal) has a smaller key value than the one to the
“right”. In contrast, a heap implements a partial order. Given their
positions, we can determine the relative order for the key values of two
nodes in the heap <em>only</em> if one is a descendant of the other.</p>
<p>Min heaps and max heaps both have their uses. For example, the <a
href="7.3-heapsort.html#heapsort" class="term"
title="A sorting algorithm that costs $\Theta(n \log n)$ time in the best, average, and worst cases. It tends to be slower than Mergesort and Quicksort. It works by building a max heap, and then repeatedly removing the item with maximum key value (moving it to the end of the heap) until all elements have been removed (and replaced at their proper location in the array).">Heapsort</a>
algorithm uses the max heap, while the <a
href="10-glossary.html#replacement-selection" class="term"
title="A variant of heapsort most often used as one phase of an external sort. Given a collection of records stored in an array, and a stream of additional records too large to fit into working memory, replacement selection will unload the heap by sending records to an output stream, and seek to bring new records into the heap from the input stream in preference to shrinking the heap size whenever possible.">Replacement
Selection</a> algorithm used for external sorting uses a min heap. The
examples in the rest of this section will sometimes use a min and
sometimes a max heap.</p>
<p>Be sure not to confuse the logical representation of a heap with its
physical implementation by means of the array-based complete binary
tree. The two are not synonymous because the logical view of the heap is
actually a tree structure, while the typical physical implementation
uses an array.</p>
<p>Here is an implementation for min heaps. It uses a <a
href="4.3-dynamic-array-based-lists.html#dynamic-array-based-lists">dynamic
array list</a> that will resize automatically when the number of
elements change.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode pseudo"><code class="sourceCode pseudo"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MinHeap <span class="kw">implements</span> <span class="bu">PriorityQueue</span>:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    MinHeap():</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.heap <span class="op">=</span> <span class="kw">new</span> DynamicArrayList()</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">getMin</span>():</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Returns the minimum element, without removing it.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">precondition</span>: <span class="va">this</span>.heap.<span class="bu">size</span>() <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">this</span>.heap[<span class="dv">0</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">add</span>(elem):</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Adds an element to the priority queue.</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> <span class="va">this</span>.heap.<span class="bu">size</span>()</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.heap.<span class="bu">add</span>(i, elem)  <span class="co">// Add the element at end of the heap.</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.siftUp(i)          <span class="co">// Put it in its correct place.</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">removeMin</span>():</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Removes and returns the minimum element.</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">precondition</span>: <span class="va">this</span>.heap.<span class="bu">size</span>() <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        removed <span class="op">=</span> <span class="va">this</span>.heap[<span class="dv">0</span>]</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> <span class="va">this</span>.heap.<span class="bu">size</span>() <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        last <span class="op">=</span> <span class="va">this</span>.heap.<span class="bu">remove</span>(i)  <span class="co">// Find and remove the last element.</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">this</span>.heap.<span class="bu">size</span>() <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>            <span class="va">this</span>.heap[<span class="dv">0</span>] <span class="op">=</span> last     <span class="co">// Replace the root with the last element.</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>            <span class="va">this</span>.siftDown(<span class="dv">0</span>)        <span class="co">// Put the new root in its correct place.</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> removed</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    siftDown(pos):</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Sift a value down the tree, return its new position.</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        heapSize <span class="op">=</span> <span class="va">this</span>.heap.<span class="bu">size</span>()</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="kw">not</span> <span class="va">this</span>.isLeaf(pos):</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>            child <span class="op">=</span> <span class="va">this</span>.getLeftChild(pos)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            right <span class="op">=</span> child <span class="op">+</span> <span class="dv">1</span>   <span class="co">// or: this.getRightChild(pos)</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> right <span class="op">&lt;</span> heapSize <span class="kw">and</span> <span class="va">this</span>.heap[right] <span class="op">&lt;</span> <span class="va">this</span>.heap[child]:</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>                child <span class="op">=</span> right   <span class="co">// &#39;child&#39; is now the index of the child with smaller value</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">this</span>.heap[child] <span class="op">&gt;=</span> <span class="va">this</span>.heap[pos]:</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> pos</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>            <span class="va">this</span>.swap(pos, child)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">=</span> child   <span class="co">// Move down one level in the tree.</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pos</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    siftUp(pos):</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Sift a value up the tree, return its new position.</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> pos <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>            parent <span class="op">=</span> <span class="va">this</span>.getParent(pos)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">this</span>.heap[pos] <span class="op">&gt;=</span> <span class="va">this</span>.heap[parent]:</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> pos</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>            <span class="va">this</span>.swap(pos, parent)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">=</span> parent   <span class="co">// Move up one level in the tree.</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pos</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    isLeaf(pos):</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Return true if pos is a leaf position.</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pos <span class="op">&gt;=</span> <span class="va">this</span>.heap.<span class="bu">size</span>() <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    getLeftChild(pos):</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Return the position for the left child of the given node.</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> pos <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    getRightChild(pos):</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Return the position for the right child of the given node.</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> pos <span class="op">+</span> <span class="dv">2</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    getParent(pos):</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Return the position for the parent. Returns 0 if we&#39;re already at the root.</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">int</span>((pos <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    swap(pos1, pos2):</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Swap the values in two positions.</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        <span class="va">this</span>.heap[pos1], <span class="va">this</span>.heap[pos2] <span class="op">=</span> <span class="va">this</span>.heap[pos2], <span class="va">this</span>.heap[pos1]</span></code></pre></div>
<p>This class definition makes two concessions to the fact that an
array-based implementation is used. First, heap nodes are indicated by
their logical position within the heap rather than by a pointer to the
node. In practice, the logical heap position corresponds to the
identically numbered physical position in the array. Second, the
constructor takes as input a pointer to the array to be used. This
approach provides the greatest flexibility for using the heap because
all data values can be loaded into the array directly by the client. The
advantage of this comes during the heap construction phase, as explained
below. The constructor also takes an integer parameter indicating the
initial size of the heap (based on the number of elements initially
loaded into the array) and a second integer parameter indicating the
maximum size allowed for the heap (the size of the array).</p>
<p>The class contains some private auxiliary methods that are use when
adding and removing elements from the heap: <code>isLeaf(pos)</code>
returns <code>true</code> if position <code>pos</code> is a leaf in the
tree, and <code>false</code> otherwise. Methods
<code>getLeftChild</code>, <code>getRightChild</code>, and
<code>getParent</code> return the position (actually, the array index)
for the left child, right child, and parent of the position passed,
respectively.</p>
<p>One way to build a heap is to insert the elements one at a time.
Method <code>add</code> will insert a new element
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
into the heap.</p>
<p>
<div id="heapinsertCON" class="ssAV" data-short-name="heapinsertCON" data-long-name="Heap insert Slideshow" alt="Heap insert Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<p>You might expect the heap insertion process to be similar to the
insert function for a BST, starting at the root and working down through
the heap. However, this approach is not likely to work because the heap
must maintain the shape of a complete binary tree. Equivalently, if the
heap takes up the first
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
positions of its array prior to the call to <code>add</code>, it must
take up the first
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math>
positions after. To accomplish this, <code>add</code> first places
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
at position
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
of the array. Of course,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
is unlikely to be in the correct position. To move
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
to the right place, it is compared to its parent’s value. If the value
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
is less than or equal to the value of its parent, then it is in the
correct place and the insert routine is finished. If the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
is greater than that of its parent, then the two elements swap
positions. From here, the process of comparing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
to its (current) parent continues until
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
reaches its correct position.</p>
<p>Since the heap is a complete binary tree, its height is guaranteed to
be the minimum possible. In particular, a heap containing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
nodes will have a height of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(\log n)</annotation></semantics></math>.
Intuitively, we can see that this must be true because each level that
we add will slightly more than double the number of nodes in the tree
(the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
th level has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>i</mi></msup><annotation encoding="application/x-tex">2^i</annotation></semantics></math>
nodes, and the sum of the first
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
levels is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{i+1}-1</annotation></semantics></math>).
Starting at 1, we can double only
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math>
times to reach a value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>.
To be precise, the height of a heap with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
nodes is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⌈</mo><mo>log</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \log n + 1 \rceil</annotation></semantics></math>.</p>
<p>Each call to <code>add</code> takes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(\log n)</annotation></semantics></math>
time in the worst case, because the value being inserted can move at
most the distance from the bottom of the tree to the top of the tree.
Thus, to insert
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
values into the heap, if we insert them one at a time, will take
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n \log n)</annotation></semantics></math>
time in the worst case.</p>
<p>
<div id="heapinsertPRO" class="embedContainer">
<iframe id="heapinsertPRO_iframe" aria-label="heapinsertPRO" src="../interactive/Binary/heapinsertPRO.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>
</p>
<section id="building-a-heap" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1"><span class="header-section-number">7.2.1</span>
Building a Heap</h3>
<p>If all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
values are available at the beginning of the building process, we can
build the heap faster than just inserting the values into the heap one
by one. Consider this example, with two possible ways to heapify an
initial set of values in an array.</p>
<div id="HeapBuild">
<p>
<div id="HeapBldChoiceCON" class="ssAV" data-short-name="HeapBldChoiceCON" data-long-name="Heap Build Choices" alt="Heap Build Choices" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<p>Two series of exchanges to build a max heap. (a) This heap is built
by a series of nine exchanges in the order (4-2), (4-1), (2-1), (5-2),
(5-4), (6-3), (6-5), (7-5), (7-6). (b) This heap is built by a series of
four exchanges in the order (5-2), (7-3), (7-1), (6-1).</p>
</div>
<p>From this example, it is clear that the heap for any given set of
numbers is not unique, and we see that some rearrangements of the input
values require fewer exchanges than others to build the heap. So, how do
we pick the best rearrangement?</p>
<p>One good algorithm stems from induction. Suppose that the left and
right subtrees of the root are already heaps, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
is the name of the element at the root. This situation is illustrated by
this figure:</p>
<div id="HeapInduct">
<p>
<div id="HeapsIndCON" class="ssAV" data-short-name="HeapsIndCON" data-long-name="Binary/HeapsIndCON" alt="Binary/HeapsIndCON" tabIndex="-1">
<div class="jsavcanvas"></div>
</div>
</p>
<p>Final stage in the heap-building algorithm. Both subtrees of node
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
are heaps. All that remains is to push
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
down to its proper level in the heap.</p>
</div>
<p>In this case there are two possibilities.</p>
<ol type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
has a value greater than or equal to its two children. In this case,
construction is complete.</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
has a value less than one or both of its children.</li>
</ol>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
should be exchanged with the child that has greater value. The result
will be a heap, except that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
might still be less than one or both of its (new) children. In this
case, we simply continue the process of “pushing down”
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
until it reaches a level where it is greater than its children, or is a
leaf node. This process is implemented by the private method
<code>siftDown</code>.</p>
<p>This approach assumes that the subtrees are already heaps, suggesting
that a complete algorithm can be obtained by visiting the nodes in some
order such that the children of a node are visited <em>before</em> the
node itthis. One simple way to do this is simply to work from the high
index of the array to the low index. Actually, the build process need
not visit the leaf nodes (they can never move down because they are
already at the bottom), so the building algorithm can start in the
middle of the array, with the first internal node.</p>
<p>Here is a visualization of the heap build process.</p>
<p>
<div id="heapbuildCON" class="ssAV" data-short-name="heapbuildCON" data-long-name="Heapbuild Slideshow" alt="Heapbuild Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<p>Method <code>buildHeap</code> implements the building algorithm.</p>
<p>
<div id="heapbuildPRO" class="embedContainer">
<iframe id="heapbuildPRO_iframe" aria-label="heapbuildPRO" src="../interactive/Binary/heapbuildPRO.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>
</p>
<p>What is the cost of <code>buildHeap</code>? Clearly it is the sum of
the costs for the calls to <code>siftDown</code>. Each
<code>siftDown</code> operation can cost at most the number of levels it
takes for the node being sifted to reach the bottom of the tree. In any
complete tree, approximately half of the nodes are leaves and so cannot
be moved downward at all. One quarter of the nodes are one level above
the leaves, and so their elements can move down at most one level. At
each step up the tree we get half the number of nodes as were at the
previous level, and an additional height of one. The maximum sum of
total distances that elements can go is therefore</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mo>log</mo><mi>n</mi></mrow></munderover><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mfrac><mi>n</mi><msup><mn>2</mn><mi>i</mi></msup></mfrac></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mfrac><mi>n</mi><mn>2</mn></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mo>log</mo><mi>n</mi></mrow></munderover><mfrac><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{eqnarray}
\sum_{i=1}^{\log n} (i-1)\frac{n}{2^i}
&amp;=&amp; \frac{n}{2}\sum_{i=1}^{\log n} \frac{i-1}{2^{i-1}}
\end{eqnarray}
</annotation></semantics></math></p>
<p>The summation on the right <a href="10-glossary.html#summation"
class="term"
title="The sum of costs for some function applied to a range of parameter values. Often written using Sigma notation. For example, the sum of the integers from 1 to $n$ can be written as $\sum_{i=1}^{n} i$.">is
known</a> to have a closed-form solution of approximately 2, so this
algorithm takes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math>
time in the worst case. This is far better than building the heap one
element at a time, which would cost
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n \log n)</annotation></semantics></math>
in the worst case. It is also faster than the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n \log n)</annotation></semantics></math>
average-case time and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(n^2)</annotation></semantics></math>
worst-case time required to build the BST.</p>
<p>
<div id="heapbuildProofCON" class="ssAV" data-short-name="heapbuildProofCON" data-long-name="Heap build analysis proof Slideshow" alt="Heap build analysis proof Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
</section>
<section id="removing-from-the-heap-or-updating-an-objects-priority"
class="level3" data-number="7.2.2">
<h3 data-number="7.2.2"><span class="header-section-number">7.2.2</span>
Removing from the heap or updating an object’s priority</h3>
<p>
<div id="heapmaxCON" class="ssAV" data-short-name="heapmaxCON" data-long-name="Remove Max Slideshow" alt="Remove Max Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<p>Because the heap is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math>
levels deep, the cost of deleting the maximum element is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Θ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\Theta(\log n)</annotation></semantics></math>
in the average and worst cases.</p>
<p>
<div id="heapremovePRO" class="embedContainer">
<iframe id="heapremovePRO_iframe" aria-label="heapremovePRO" src="../interactive/Binary/heapremovePRO.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>
</p>
<div class="line-block"></div>
<p>
<div id="heapremoveCON" class="ssAV" data-short-name="heapremoveCON" data-long-name="Remove Any Slideshow" alt="Remove Any Slideshow" tabIndex="-1">
<span class="jsavcounter"></span>
<div class="jsavcontrols"></div>
<p class="jsavoutput jsavline"></p>
<div class="jsavcanvas"></div>
</div>
</p>
<p>For some applications, objects might get their priority modified. One
solution in this case is to remove the object and reinsert it. To do
this, the application needs to know the position of the object in the
heap. Another option is to change the priority value of the object, and
then update its position in the heap. Note that a remove operation
implicitly has to do this anyway, since when the last element in the
heap is swapped with the one being removed, that value might be either
too small or too big for its new position. So we use a utility method
called <code>update</code> in both the <code>remove</code> and
<code>modify</code> methods to handle this process.</p>
</section>
<section id="binary-heaps-as-priority-queues" class="level3"
data-number="7.2.3">
<h3 data-number="7.2.3"><span class="header-section-number">7.2.3</span>
Binary Heaps as Priority Queues</h3>
<p>The heap is a natural implementation for the priority queue discussed
at the beginning of this section. Jobs can be added to the heap (using
their priority value as the ordering key) when needed. Method
<code>removeMin</code> can be called whenever a new job is to be
executed.</p>
<p>Priority queues can be helpful for solving graph problems such as the
<a href="10-glossary.html#single-source-shortest-paths-problem"
class="term"
title="Given a graph with weights or distances on the edges, and a designated start vertex $s$, find the shortest path from $s$ to every other vertex in the graph. One algorithm to solve this problem is Dijkstra&#39;s algorithm.">single-source
shortest paths problem</a> and finding the <a
href="10-glossary.html#minimal-cost-spanning-tree" class="term"
title="Abbreviated as MCST, or sometimes as MST. Derived from a weighted graph, the MCST is the subset of the graph&#39;s edges that maintains the connectivitiy of the graph while having lowest total cost (as defined by the sum of the weights of the edges in the MCST). The result is referred to as a tree because it would never have a cycle (since an edge could be removed from the cycle and still preserve connectivity). Two algorithms to solve this problem are Prim&#39;s algorithm and Kruskal&#39;s algorithm.">minimal-cost
spanning tree</a>.</p>
<p>For a story about Priority Queues and dragons, see <a
href="http://computationaltales.blogspot.com/2011/04/stacks-queues-priority-queues-and.html">Computational
Fairy Tales: Stacks, Queues, Priority Queues, and the Prince’s Complaint
Line</a></p>
<section id="changing-the-priority-of-elements" class="level4"
data-number="7.2.3.1">
<h4 data-number="7.2.3.1"><span
class="header-section-number">7.2.3.1</span> Changing the priority of
elements</h4>
<p>Some applications of priority queues require the ability to change
the priority of an object already stored in the queue. This might
require that the object’s position in the heap representation be
updated. Unfortunately, a min heap is not efficient when searching for
an arbitrary value; it is only good for finding the minimum value.
However, if we already know the index for an object within the heap, it
is a simple matter to update its priority (including changing its
position to maintain the heap property) or remove it.</p>
<p>A typical implementation for priority queues requiring updating of
priorities will need to use an auxiliary data structure that supports
efficient search for objects (such as a BST). Records in the auxiliary
data structure will store the object’s heap index, so that the object’s
priority can be updated.</p>
</section>
<section id="practice-questions-4" class="level4" data-number="7.2.3.2">
<h4 data-number="7.2.3.2"><span
class="header-section-number">7.2.3.2</span> Practice Questions</h4>
<p>
<div id="HeapSumm" class="embedContainer">
<iframe id="HeapSumm_iframe" aria-label="HeapSumm" src="../interactive/Binary/HeapSumm.html" width="100%" height="600" scrolling="no">
Your browser does not support iframes.
</iframe>
</div>
</p>
</section>
</section>
</section>
<script type="text/javascript" src="../interactive/DataStructures/binaryheap.js"></script>
<script type="text/javascript" src="../interactive/Binary/heapinsertCON.js"></script>
<script type="text/javascript" src="../interactive/Binary/HeapBldChoiceCON.js"></script>
<script type="text/javascript" src="../interactive/Binary/HeapsIndCON.js"></script>
<script type="text/javascript" src="../interactive/Binary/heapbuildCON.js"></script>
<script type="text/javascript" src="../interactive/Binary/heapbuildProofCON.js"></script>
<script type="text/javascript" src="../interactive/Binary/heapmaxCON.js"></script>
<script type="text/javascript" src="../interactive/Binary/heapremoveCON.js"></script>
</body>
</html>

