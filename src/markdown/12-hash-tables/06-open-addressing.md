
## Open addressing

::: TODO
- Prio 2: invariants
- Prio 2:
    - Discuss: Load factor, what is a good LF?
    - Discuss: When to resize
- Prio 2: give overview implementation, not for a specific ADT (set/map)
:::


### Hash tables without buckets

We now turn to the most commonly used form of hashing:
[open addressing]{.term} (also called [closed hashing](#closed-hash-system){.term})
with no bucketing, and a [collision resolution policy]{.term} that can potentially use any slot in the hash table.

Compared to [separate chaining](#separate-chaining),
we will now have room for exactly one entry in each table
cell. If we want to implement a **HashMap** (not a HashSet), we then
need to be able to put both a key and a value in the same table cell.

This can be done in two ways: either one array of key-value paris,
or two arrays of the same length -- one for the keys and another for the values.
Here we will use the second approach.

Now we can initialise our open addressing hash map. In addition to the
keys and values arrays, we need a counter of the size, and the number
of deleted cells (which is explained
[later in this chapter](#open-addressing-deletion)).

    datatype OpenAddressingHashMap of K to V implements Map:
        keys: Array of K = new Array(MIN_CAPACITY)
        values: Array of V = new Array(MIN_CAPACITY)
        size: Int = 0
        deleted: Int = 0

We use the same constants as for the separate chaining map, but the
values are different. Most importantly, the max load factor must be
smaller than 1, since there can only be one value per array slot.

    datatype OpenAddressingHashMap implements Map:
        ...
        MIN_CAPACITY = 8
        MIN_LOAD_FACTOR = 0.3
        MAX_LOAD_FACTOR = 0.7
        MULTIPLIER = 1.5

Finding a good table index for a key is done in the same way as for
[separate chaining hash tables](#converting-objects-to-table-indices):

    datatype OpenAddressingHashMap implements Map:
        ...
        hash(key):
            h = key.hashCode() & 0x7fffffff
            return h % keys.size

### Collision resolution

The goal of [collision resolution]{.term} is to
find a free slot in the hash table when the "home position" for the
record is already occupied. We can view any collision resolution method
as generating a sequence of hash table slots that can potentially hold
the record. The first slot in the sequence will be the home position for
the key. If the home position is occupied, then the collision resolution
policy goes to the next slot in the sequence. If this is occupied as
well, then another slot must be found, and so on. This sequence of slots
is known as the [probe sequence]{.term}, and it
is generated by some [probe function]{.term}
that we will call **p** (or `probe` in the source code). Probing works
as follows.

    datatype OpenAddressingHashMap implements Map:
        ...
        hashAndProbe(key):
            home = hash(key)
            for i in 0 .. keys.size-1:
                pos = (home + probe(key, i)) % keys.size
                k = keys[pos]
                if k is null or k == key:
                    return pos
            throw error "Hash table full"

        probe(key, i):
            return i   // Linear probing
            // return i*i  // Quadratic probing


The method `hashAndProbe` first calculates the *home slot*, which is the
hash code compressed to an index in the internal hash array. Then it
uses the probe function $\textbf{p}(k, i)$ to locate a free slot in the
table. Function **p** has two parameters, the key $k$ and a count $i$ of
where in the probe sequence we wish to be. That is, to get the first
position in the probe sequence for key $K$, we call $\textbf{p}(K, 0)$.
For the next slot in the probe sequence, call $\textbf{p}(K, 1)$, then
$\textbf{p}(K, 2)$, etc. If the key is already in the table,
`hashAndProbe` returns the position of that entry, otherwise it returns
the position of the first unoccupied slot.

Note that the probe function returns an offset from the original home
position, rather than a slot in the hash table. Thus, the `for` loop in
`hashAndProbe` is computing positions in the table at each iteration by
adding the value returned from the probe function to the home position.
The $i$ th call to **p** returns the $i$ th offset to be used.

### Invariants


### Linear probing

The simplest approach to collision resolution is simply to move down the
table from the home slot until a free slot is found. This is known as
[linear probing]{.term}. The probe function for
simple linear probing is $\textbf{p}(K, i) = i$. That is, the $i$ th
offset on the probe sequence is just $i$, meaning that the $i$ th step
is simply to move down $i$ slots in the table. Once the bottom of the
table is reached, the probe sequence wraps around to the beginning of
the table (since the last step is to mod the result to the table size).
Linear probing has the virtue that all slots in the table will be
candidates for inserting a new record before the probe sequence returns
to the home position.

::: dsvis
Can you see any reason why this might not be the best approach to
collision resolution?

<inlineav id="linProbeCON1" src="Hashing/linProbeCON1.js" name="Linear Probing Slideshow 1" links="Hashing/linProbeCON.css"/>
:::

### Implementation

::: TODO
- just simple implementation, don't show set/map ADT
:::
