
# Trees

::: TODO
- Prio 2: update introduction
:::

[Tree]{.term} structures enable efficient
access and efficient update to large collections of data.
[Binary trees]{.term} in
particular are widely used and relatively easy to implement. But binary
trees are useful for many things besides searching. Just a few examples
of applications that trees can speed up include
describing mathematical expressions
and the syntactic elements of computer programs
(using expression trees, see @sec:differentiating-between-internal-nodes-and-leaves),
prioritising jobs (using binary heaps, see @sec:binary-heaps), or
organising the information needed to drive
data compression algorithms (using Huffman coding, see @sec:case-study-huffman-coding).

This chapter covers terminology used for discussing binary trees (@sec:binary-trees),
tree traversals (@sec:traversing-a-binary-tree),
approaches to implementing tree nodes (@sec:implementing-binary-trees),
and various examples of binary trees.
The chapter concludes by discussing non-binary trees, i.e., trees with more (or less) than two children (@sec:general-trees).

